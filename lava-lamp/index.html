<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Mobile Ready Lava</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Segoe UI', sans-serif;
            user-select: none;
            -webkit-user-select: none;
            /* Safari */
            touch-action: none;
            /* Prevent browser zooming/scrolling globally */
        }

        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        /* UI Overlay */
        .ui-container {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(5, 5, 5, 0.9);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            padding: 15px 20px;
            /* Compact padding for mobile */
            border-radius: 16px;
            display: flex;
            gap: 12px;
            align-items: flex-end;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.9);
            transition: opacity 0.3s, transform 0.3s;
            opacity: 0;
            transform: translateX(-50%) translateY(20px);
            z-index: 10;

            /* Ensure UI fits on small screens */
            max-width: 95vw;
            overflow-x: auto;
            /* Scroll horizontally if needed on tiny screens */
            scrollbar-width: none;
            /* Hide scrollbar Firefox */
        }

        /* Hide scrollbar Webkit */
        .ui-container::-webkit-scrollbar {
            display: none;
        }

        /* Mobile Optimization: Show UI on tap or hover */
        body:hover .ui-container,
        body:active .ui-container {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }

        .control-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
            min-width: 50px;
            /* Ensure touch targets are big enough */
        }

        label {
            color: #888;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 700;
            pointer-events: none;
        }

        input[type="color"] {
            width: 40px;
            height: 35px;
            /* Taller for touch */
            border: none;
            cursor: pointer;
            padding: 0;
            background: none;
        }

        input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 0;
        }

        input[type="color"]::-webkit-color-swatch {
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 4px;
        }

        input[type="number"] {
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: #eee;
            width: 55px;
            padding: 8px 0;
            /* Taller for touch */
            border-radius: 4px;
            font-family: 'Consolas', monospace;
            font-size: 14px;
            text-align: center;
            outline: none;
            cursor: ew-resize;
            transition: background 0.2s, border-color 0.2s;
            -moz-appearance: textfield;
        }

        input[type="number"]:focus {
            background: rgba(255, 255, 255, 0.2);
            border-color: #00ff00;
            color: #fff;
        }

        /* Remove arrows */
        input[type=number]::-webkit-inner-spin-button,
        input[type=number]::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
    </style>
</head>

<body>

    <canvas id="glCanvas"></canvas>

    <div class="ui-container">
        <div class="control-group">
            <label>Void</label>
            <input type="color" id="bgColor">
        </div>
        <div class="control-group">
            <label>Neon</label>
            <input type="color" id="blobColor">
        </div>
        <div class="control-group">
            <label>Zoom</label>
            <input type="number" id="zoomInput" step="0.1" min="0.1">
        </div>
        <div class="control-group">
            <label>Glow</label>
            <input type="number" id="bloomInput" step="1">
        </div>
        <div class="control-group">
            <label>Core</label>
            <input type="number" id="densityInput" step="1">
        </div>
        <div class="control-group">
            <label>Speed</label>
            <input type="number" id="speedInput" step="0.1">
        </div>
    </div>

    <!-- VERTEX SHADER -->
    <script type="x-shader/x-vertex" id="vert-shader">
        #version 300 es
        in vec4 a_position;
        void main() {
            gl_Position = a_position;
        }
    </script>

    <!-- FRAGMENT SHADER -->
    <script type="x-shader/x-fragment" id="frag-shader">
        #version 300 es
        precision highp float;

        uniform vec2 u_resolution;
        uniform float u_time;
        uniform vec3 u_bgCol;
        uniform vec3 u_blobCol;
        uniform float u_density; 
        uniform float u_speed;
        uniform float u_bloom; 
        uniform float u_zoom; 

        out vec4 outColor;

        float hash(float n) { return fract(sin(n) * 43758.5453); }

        vec3 ACESFilm(vec3 x) {
            float a = 2.51;
            float b = 0.03;
            float c = 2.43;
            float d = 0.59;
            float e = 0.14;
            return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0.0, 1.0);
        }

        void main() {
            vec2 uv = (gl_FragCoord.xy * 2.0 - u_resolution.xy) / min(u_resolution.x, u_resolution.y);
            uv *= u_zoom;

            float energy = 0.0;
            const int NUM_BLOBS = 60; 

            for(int i = 0; i < NUM_BLOBS; i++) {
                float fi = float(i);
                float seed = fi * 55.123;
                
                float radius = 0.5 + hash(seed) * 0.6;
                float speedMultiplier = 0.1 * (u_speed * 0.2);
                float speedX = (hash(seed + 1.0) - 0.5) * speedMultiplier;
                float speedY = (hash(seed + 2.0) - 0.5) * speedMultiplier;
                float offsetX = hash(seed + 3.0) * 100.0;
                float offsetY = hash(seed + 4.0) * 100.0;

                float x = sin(u_time * speedX + offsetX) * 16.0; 
                float y = cos(u_time * speedY + offsetY) * 12.0; 
                
                vec2 pos = vec2(x, y);
                float dist = length(uv - pos);
                
                energy += (radius * radius) / (dist * dist + 0.01); 
            }

            float glow = pow(energy, 0.75);
            
            // Inverse Density Math
            float coreThreshold = max(0.02, 40.0 / max(1.0, u_density));
            float core = smoothstep(coreThreshold, coreThreshold + 0.5, energy);

            vec3 col = u_bgCol;

            // Glow Layer
            col += u_blobCol * glow * (u_bloom * 0.005);

            // Core Layer
            col += u_blobCol * core * 8.0;

            col = ACESFilm(col);

            vec2 vUv = gl_FragCoord.xy / u_resolution.xy;
            float vign = 1.0 - length((vUv - 0.5) * 1.5);
            vign = smoothstep(-0.2, 0.8, vign);
            col *= vign;

            float noise = fract(sin(dot(gl_FragCoord.xy, vec2(12.9898, 78.233))) * 43758.5453);
            col += (noise - 0.5) * 0.01;

            col = pow(col, vec3(1.0/2.2));

            outColor = vec4(col, 1.0);
        }
    </script>

    <!-- JAVASCRIPT -->
    <script>
        // CONFIG
        const INITIAL_CONFIG = {
            VOID_COLOR: "#000000",
            NEON_COLOR: "#00ff00",
            ZOOM: 6.4,
            GLOW: -10,
            CORE_SIZE: 81,
            SPEED: 18.2
        };

        const canvas = document.getElementById('glCanvas');
        const gl = canvas.getContext('webgl2');

        if (!gl) document.body.innerHTML = "WebGL2 Not Supported";

        // Initialize UI
        const ui = {
            bg: document.getElementById('bgColor'),
            blob: document.getElementById('blobColor'),
            zoom: document.getElementById('zoomInput'),
            bloom: document.getElementById('bloomInput'),
            density: document.getElementById('densityInput'),
            speed: document.getElementById('speedInput')
        };

        ui.bg.value = INITIAL_CONFIG.VOID_COLOR;
        ui.blob.value = INITIAL_CONFIG.NEON_COLOR;
        ui.zoom.value = INITIAL_CONFIG.ZOOM;
        ui.bloom.value = INITIAL_CONFIG.GLOW;
        ui.density.value = INITIAL_CONFIG.CORE_SIZE;
        ui.speed.value = INITIAL_CONFIG.SPEED;


        // --- Shader Boilerplate ---
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) return null;
            return shader;
        }

        function createProgram(gl, vertSource, fragSource) {
            const vert = createShader(gl, gl.VERTEX_SHADER, vertSource);
            const frag = createShader(gl, gl.FRAGMENT_SHADER, fragSource);
            const prog = gl.createProgram();
            gl.attachShader(prog, vert);
            gl.attachShader(prog, frag);
            gl.linkProgram(prog);
            return prog;
        }

        const vertSrc = document.getElementById('vert-shader').text.trim();
        const fragSrc = document.getElementById('frag-shader').text.trim();
        const program = createProgram(gl, vertSrc, fragSrc);

        const posLoc = gl.getAttribLocation(program, "a_position");
        const posBuf = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, posBuf);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1]), gl.STATIC_DRAW);

        const uRes = gl.getUniformLocation(program, "u_resolution");
        const uTime = gl.getUniformLocation(program, "u_time");
        const uBgCol = gl.getUniformLocation(program, "u_bgCol");
        const uBlobCol = gl.getUniformLocation(program, "u_blobCol");
        const uDensity = gl.getUniformLocation(program, "u_density");
        const uSpeed = gl.getUniformLocation(program, "u_speed");
        const uBloom = gl.getUniformLocation(program, "u_bloom");
        const uZoom = gl.getUniformLocation(program, "u_zoom");

        // --- UNIFIED INPUT HANDLER (MOUSE & TOUCH) ---
        function enableSmartInput(input) {
            let startX, startValue;
            let isDragging = false;
            let moveListener, upListener;

            // Shared logic for starting a drag
            const onStart = (clientX) => {
                startX = clientX;
                startValue = parseFloat(input.value);
                isDragging = false;
            };

            // Shared logic for moving
            const onMove = (clientX, e) => {
                // Determine if we are past the threshold to consider this a drag
                if (!isDragging && Math.abs(clientX - startX) > 5) {
                    isDragging = true;
                    input.blur();
                    document.body.style.cursor = 'ew-resize';
                    window.getSelection().removeAllRanges();
                }

                if (isDragging) {
                    if (e.cancelable) e.preventDefault(); // Stop mobile scroll

                    const deltaX = clientX - startX;
                    const step = parseFloat(input.step) || 1;

                    // On mobile, increase sensitivity slightly
                    const sensitivity = e.type.startsWith('touch') ? 1.5 : 1.0;

                    let newValue = startValue + (deltaX * step * sensitivity);

                    if (step < 1) newValue = Math.round(newValue * 10) / 10;
                    else newValue = Math.round(newValue);

                    if (input.min) newValue = Math.max(parseFloat(input.min), newValue);
                    if (input.max) newValue = Math.min(parseFloat(input.max), newValue);

                    input.value = newValue;
                    input.dispatchEvent(new Event('input'));
                }
            };

            const onEnd = () => {
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
                document.removeEventListener('touchmove', onTouchMove);
                document.removeEventListener('touchend', onTouchEnd);
                document.body.style.cursor = '';
            };

            // --- Mouse Listeners ---
            const onMouseMove = (e) => onMove(e.clientX, e);
            const onMouseUp = () => onEnd();

            input.addEventListener('mousedown', (e) => {
                onStart(e.clientX);
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            });

            // --- Touch Listeners ---
            const onTouchMove = (e) => onMove(e.touches[0].clientX, e);
            const onTouchEnd = () => onEnd();

            input.addEventListener('touchstart', (e) => {
                onStart(e.touches[0].clientX);
                document.addEventListener('touchmove', onTouchMove, { passive: false });
                document.addEventListener('touchend', onTouchEnd);
            }, { passive: false });
        }

        document.querySelectorAll('input[type="number"]').forEach(enableSmartInput);

        function hexToRgb(hex) {
            const bigint = parseInt(hex.slice(1), 16);
            return [(bigint >> 16 & 255) / 255, (bigint >> 8 & 255) / 255, (bigint & 255) / 255];
        }

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        window.addEventListener('resize', resize);
        resize();

        function render(time) {
            time *= 0.001;

            gl.useProgram(program);
            gl.enableVertexAttribArray(posLoc);
            gl.bindBuffer(gl.ARRAY_BUFFER, posBuf);
            gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

            gl.uniform2f(uRes, canvas.width, canvas.height);
            gl.uniform1f(uTime, time);

            const bg = hexToRgb(ui.bg.value);
            gl.uniform3f(uBgCol, bg[0], bg[1], bg[2]);

            const blob = hexToRgb(ui.blob.value);
            gl.uniform3f(uBlobCol, blob[0], blob[1], blob[2]);

            gl.uniform1f(uDensity, parseFloat(ui.density.value));
            gl.uniform1f(uSpeed, parseFloat(ui.speed.value));
            gl.uniform1f(uBloom, parseFloat(ui.bloom.value));
            gl.uniform1f(uZoom, parseFloat(ui.zoom.value));

            gl.drawArrays(gl.TRIANGLES, 0, 6);
            requestAnimationFrame(render);
        }

        requestAnimationFrame(render);
    </script>
</body>

</html>