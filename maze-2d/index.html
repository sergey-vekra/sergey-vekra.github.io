<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Isometric Infinite Maze (WebGL2)</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #111;
            touch-action: none;
            font-family: monospace;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* UI OVERLAY */
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #ffcc00;
            background: rgba(0, 0, 0, 0.8);
            padding: 8px;
            border: 1px solid #ffcc00;
            pointer-events: none;
            z-index: 10;
        }

        /* TOUCH CONTROLS */
        #controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 140px;
            height: 140px;
            display: none;
            z-index: 20;
        }

        .btn {
            position: absolute;
            width: 40px;
            height: 40px;
            border: 2px solid #ffcc00;
            background: rgba(255, 204, 0, 0.2);
            color: #ffcc00;
            text-align: center;
            line-height: 40px;
            font-weight: bold;
            border-radius: 8px;
            user-select: none;
        }

        .btn:active {
            background: #ffcc00;
            color: #000;
        }

        #btn-up {
            top: 0;
            left: 50px;
        }

        #btn-down {
            bottom: 0;
            left: 50px;
        }

        #btn-left {
            top: 50px;
            left: 0;
        }

        #btn-right {
            top: 50px;
            right: 0;
        }

        @media (hover: none) and (pointer: coarse) {
            #controls {
                display: block;
            }
        }
    </style>
</head>

<body>
    <div id="ui">Pos: <span id="pos">0, 0</span></div>

    <div id="controls">
        <div id="btn-up" class="btn">W</div>
        <div id="btn-down" class="btn">S</div>
        <div id="btn-left" class="btn">A</div>
        <div id="btn-right" class="btn">D</div>
    </div>

    <canvas id="glCanvas"></canvas>

    <!-- SHADERS -->
    <script id="vs" type="x-shader/x-vertex">#version 300 es
        // Inputs
        layout(location = 0) in vec3 a_position;    // Cube geometry
        layout(location = 1) in vec3 a_normal;      // Lighting normals
        layout(location = 2) in vec2 a_instancePos; // X,Z offset for walls
        
        // Uniforms
        uniform mat4 u_viewProj;    // Combined Ortho + Camera Matrix
        uniform vec3 u_modelOffset; // Player position (or 0 for walls)
        uniform float u_rotation;   // Player rotation
        uniform float u_scale;      // Scale
        uniform bool u_isInstanced; // Mode switch

        // Output to Fragment Shader
        out vec3 v_normal;

        void main() {
            vec3 pos = a_position * u_scale;

            // Rotate Player (Y-axis rotation)
            if (u_rotation != 0.0) {
                float c = cos(u_rotation);
                float s = sin(u_rotation);
                // Rotate around Y
                float nx = pos.x * c - pos.z * s;
                float nz = pos.x * s + pos.z * c;
                pos.x = nx;
                pos.z = nz;
            }

            // Translate
            if (u_isInstanced) {
                // Wall Mode: a_instancePos contains X and Z coordinates
                // We map them to World X and Z. Y is 0.
                pos = pos + vec3(a_instancePos.x, 0.0, a_instancePos.y);
            } else {
                // Player Mode
                pos = pos + u_modelOffset;
            }

            v_normal = a_normal; // Pass normal for lighting
            gl_Position = u_viewProj * vec4(pos, 1.0);
        }
    </script>

    <script id="fs" type="x-shader/x-fragment">#version 300 es
        precision mediump float;
        
        in vec3 v_normal;
        uniform vec4 u_color;
        
        out vec4 outColor;

        void main() {
            // Simple Directional Lighting
            // Light coming from top-right-front
            vec3 lightDir = normalize(vec3(0.5, 1.0, 0.7));
            
            // Diffuse calculation
            // If u_rotation is used, normals should technically be rotated too, 
            // but for a simple cube player it looks acceptable without it.
            float diff = max(dot(normalize(v_normal), lightDir), 0.3); // 0.3 is Ambient

            outColor = vec4(u_color.rgb * diff, u_color.a);
        }
    </script>

    <script>
        // ==========================================
        // 0. MATH HELPERS (Minimal Mat4)
        // ==========================================
        const Mat4 = {
            create: () => new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
            ortho: (out, left, right, bottom, top, near, far) => {
                let lr = 1 / (left - right), bt = 1 / (bottom - top), nf = 1 / (near - far);
                out[0] = -2 * lr; out[5] = -2 * bt; out[10] = 2 * nf;
                out[12] = (left + right) * lr; out[13] = (top + bottom) * bt; out[14] = (far + near) * nf;
                return out;
            },
            rotateX: (out, rad) => {
                let s = Math.sin(rad), c = Math.cos(rad);
                let a10 = out[4], a11 = out[5], a12 = out[6], a13 = out[7];
                let a20 = out[8], a21 = out[9], a22 = out[10], a23 = out[11];
                out[4] = a10 * c + a20 * s; out[5] = a11 * c + a21 * s; out[6] = a12 * c + a22 * s; out[7] = a13 * c + a23 * s;
                out[8] = a20 * c - a10 * s; out[9] = a21 * c - a11 * s; out[10] = a22 * c - a12 * s; out[11] = a23 * c - a13 * s;
            },
            rotateY: (out, rad) => {
                let s = Math.sin(rad), c = Math.cos(rad);
                let a00 = out[0], a01 = out[1], a02 = out[2], a03 = out[3];
                let a20 = out[8], a21 = out[9], a22 = out[10], a23 = out[11];
                out[0] = a00 * c - a20 * s; out[1] = a01 * c - a21 * s; out[2] = a02 * c - a22 * s; out[3] = a03 * c - a23 * s;
                out[8] = a00 * s + a20 * c; out[9] = a01 * s + a21 * c; out[10] = a02 * s + a22 * c; out[11] = a03 * s + a23 * c;
            },
            translate: (out, x, y, z) => {
                out[12] += out[0] * x + out[4] * y + out[8] * z;
                out[13] += out[1] * x + out[5] * y + out[9] * z;
                out[14] += out[2] * x + out[6] * y + out[10] * z;
                out[15] += out[3] * x + out[7] * y + out[11] * z;
            }
        };

        // ==========================================
        // 1. SETUP
        // ==========================================
        const canvas = document.getElementById("glCanvas");
        const gl = canvas.getContext("webgl2", { alpha: false, depth: true, antialias: true });
        if (!gl) throw "WebGL2 required";

        function createShader(gl, type, src) {
            const s = gl.createShader(type); gl.shaderSource(s, src); gl.compileShader(s);
            if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) console.error(gl.getShaderInfoLog(s));
            return s;
        }
        const p = gl.createProgram();
        gl.attachShader(p, createShader(gl, gl.VERTEX_SHADER, document.getElementById("vs").text));
        gl.attachShader(p, createShader(gl, gl.FRAGMENT_SHADER, document.getElementById("fs").text));
        gl.linkProgram(p);
        gl.useProgram(p);

        // ==========================================
        // 2. GEOMETRY (Cube)
        // ==========================================
        // 36 vertices (6 faces * 2 triangles * 3 verts)
        // Format: x,y,z, nx,ny,nz (Position, Normal)
        const cubeData = new Float32Array([
            // Top (y=0.5)
            -0.5, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0.5, 0, 1, 0,
            -0.5, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0.5, 0, 1, 0, -0.5, 0.5, 0.5, 0, 1, 0,
            // Front (z=0.5)
            -0.5, -0.5, 0.5, 0, 0, 1, 0.5, -0.5, 0.5, 0, 0, 1, 0.5, 0.5, 0.5, 0, 0, 1,
            -0.5, -0.5, 0.5, 0, 0, 1, 0.5, 0.5, 0.5, 0, 0, 1, -0.5, 0.5, 0.5, 0, 0, 1,
            // Right (x=0.5)
            0.5, -0.5, 0.5, 1, 0, 0, 0.5, -0.5, -0.5, 1, 0, 0, 0.5, 0.5, -0.5, 1, 0, 0,
            0.5, -0.5, 0.5, 1, 0, 0, 0.5, 0.5, -0.5, 1, 0, 0, 0.5, 0.5, 0.5, 1, 0, 0,
            // Back (z=-0.5)
            -0.5, -0.5, -0.5, 0, 0, -1, -0.5, 0.5, -0.5, 0, 0, -1, 0.5, 0.5, -0.5, 0, 0, -1,
            -0.5, -0.5, -0.5, 0, 0, -1, 0.5, 0.5, -0.5, 0, 0, -1, 0.5, -0.5, -0.5, 0, 0, -1,
            // Left (x=-0.5)
            -0.5, -0.5, -0.5, -1, 0, 0, -0.5, -0.5, 0.5, -1, 0, 0, -0.5, 0.5, 0.5, -1, 0, 0,
            -0.5, -0.5, -0.5, -1, 0, 0, -0.5, 0.5, 0.5, -1, 0, 0, -0.5, 0.5, -0.5, -1, 0, 0,
            // Bottom (y=-0.5)
            -0.5, -0.5, -0.5, 0, -1, 0, 0.5, -0.5, 0.5, 0, -1, 0, 0.5, -0.5, -0.5, 0, -1, 0,
            -0.5, -0.5, -0.5, 0, -1, 0, -0.5, -0.5, 0.5, 0, -1, 0, 0.5, -0.5, 0.5, 0, -1, 0
        ]);

        const vao = gl.createVertexArray();
        gl.bindVertexArray(vao);

        const vbo = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
        gl.bufferData(gl.ARRAY_BUFFER, cubeData, gl.STATIC_DRAW);

        // Attrib 0: Position (3 floats, stride 24, offset 0)
        gl.enableVertexAttribArray(0);
        gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 24, 0);
        // Attrib 1: Normal (3 floats, stride 24, offset 12)
        gl.enableVertexAttribArray(1);
        gl.vertexAttribPointer(1, 3, gl.FLOAT, false, 24, 12);

        // Instance Buffer (X, Z coords only)
        const iBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, iBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, 0, gl.DYNAMIC_DRAW);
        gl.enableVertexAttribArray(2);
        gl.vertexAttribPointer(2, 2, gl.FLOAT, false, 0, 0);
        gl.vertexAttribDivisor(2, 1); // 1 per instance

        // ==========================================
        // 3. MAZE & LOGIC
        // ==========================================
        function hash(x, y) {
            let n = Math.sin(x * 12.9898 + y * 78.233) * 43758.5453;
            return n - Math.floor(n);
        }
        function isWall(gx, gy) {
            const xEven = (gx % 2 === 0), yEven = (gy % 2 === 0);
            if (xEven && yEven) return true;
            if (!xEven && !yEven) return false;
            return !xEven && yEven ? hash(gx, gy + 1) >= 0.5 : hash(gx + 1, gy) < 0.5;
        }

        let playerPos = { x: 1.5, z: 1.5 }; // Note: Using Z now for 3D logic
        let playerAngle = 0;

        while (isWall(Math.floor(playerPos.x), Math.floor(playerPos.z))) playerPos.x += 1;

        // ==========================================
        // 4. INPUTS
        // ==========================================
        const keys = {};
        const touch = { up: false, down: false, left: false, right: false };
        window.addEventListener("keydown", e => keys[e.code] = true);
        window.addEventListener("keyup", e => keys[e.code] = false);
        const bindT = (id, k) => {
            const el = document.getElementById(id);
            const s = (v) => (e) => { e.preventDefault(); touch[k] = v; };
            el.addEventListener("touchstart", s(true)); el.addEventListener("touchend", s(false));
            el.addEventListener("mousedown", s(true)); el.addEventListener("mouseup", s(false));
        };
        bindT("btn-up", "up"); bindT("btn-down", "down"); bindT("btn-left", "left"); bindT("btn-right", "right");

        // ==========================================
        // 5. RENDER LOOP
        // ==========================================
        let matViewProj = new Float32Array(16);

        function resize() {
            const r = window.devicePixelRatio || 1;
            canvas.width = window.innerWidth * r;
            canvas.height = window.innerHeight * r;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        window.addEventListener("resize", resize);
        resize();

        function updateAndRender() {
            // --- LOGIC ---
            const speed = 0.08, rotSpeed = 0.06;
            if (keys["KeyA"] || touch.left) playerAngle += rotSpeed;
            if (keys["KeyD"] || touch.right) playerAngle -= rotSpeed;

            const sin = Math.sin(playerAngle), cos = Math.cos(playerAngle);
            let dx = 0, dz = 0;
            if (keys["KeyW"] || touch.up) { dx -= sin * speed; dz -= cos * speed; }
            if (keys["KeyS"] || touch.down) { dx += sin * speed; dz += cos * speed; }

            if (dx !== 0 || dz !== 0) {
                const check = (x, z) => isWall(Math.floor(x), Math.floor(z));
                if (!check(playerPos.x + dx + 0.3, playerPos.z) && !check(playerPos.x + dx - 0.3, playerPos.z)) playerPos.x += dx;
                if (!check(playerPos.x, playerPos.z + dz + 0.3) && !check(playerPos.x, playerPos.z + dz - 0.3)) playerPos.z += dz;
            }
            document.getElementById("pos").innerText = `${Math.floor(playerPos.x)}, ${Math.floor(playerPos.z)}`;

            // --- MATRIX SETUP (ISOMETRIC) ---
            // 1. Identity
            const m = Mat4.create();
            // 2. Orthographic Projection (Zoom level 14)
            const aspect = canvas.width / canvas.height;
            const zoom = 14;
            Mat4.ortho(m, -zoom * aspect, zoom * aspect, -zoom, zoom, -50, 50);

            // 3. Camera Rotation (Isometric tilt)
            Mat4.rotateX(m, Math.PI / 3.5); // Tilt down ~50 degrees
            Mat4.rotateY(m, Math.PI / 4);   // Rotate 45 degrees

            // 4. Camera Follow (Move world opposite to player)
            // Note: We move the world -X, -Z. Center logic handles Y.
            Mat4.translate(m, -playerPos.x, -1.0, -playerPos.z);

            // --- DRAW ---
            gl.clearColor(0.15, 0.15, 0.15, 1);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            gl.enable(gl.DEPTH_TEST);
            gl.enable(gl.CULL_FACE);

            const uVP = gl.getUniformLocation(p, "u_viewProj");
            const uMod = gl.getUniformLocation(p, "u_modelOffset");
            const uRot = gl.getUniformLocation(p, "u_rotation");
            const uScl = gl.getUniformLocation(p, "u_scale");
            const uInst = gl.getUniformLocation(p, "u_isInstanced");
            const uCol = gl.getUniformLocation(p, "u_color");

            gl.uniformMatrix4fv(uVP, false, m);

            // Draw Walls
            const range = 12;
            const walls = [];
            const px = Math.floor(playerPos.x), pz = Math.floor(playerPos.z);
            for (let z = pz - range; z <= pz + range; z++) {
                for (let x = px - range; x <= px + range; x++) {
                    if (isWall(x, z)) walls.push(x + 0.5, z + 0.5);
                }
            }

            gl.bindBuffer(gl.ARRAY_BUFFER, iBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(walls), gl.DYNAMIC_DRAW);

            gl.uniform1i(uInst, true);
            gl.uniform1f(uScl, 1.0);
            gl.uniform1f(uRot, 0.0);
            gl.uniform4f(uCol, 0.4, 0.5, 0.6, 1.0); // Slate blue walls
            gl.drawArraysInstanced(gl.TRIANGLES, 0, 36, walls.length / 2);

            // Draw Player
            gl.uniform1i(uInst, false);
            gl.uniform3f(uMod, playerPos.x, 0.0, playerPos.z);
            gl.uniform1f(uScl, 0.6); // Smaller cube
            // Isometric view makes player rotation hard to see if just a plain cube, 
            // but the corners will move.
            gl.uniform1f(uRot, playerAngle);
            gl.uniform4f(uCol, 1.0, 0.8, 0.2, 1.0); // Orange player
            gl.drawArrays(gl.TRIANGLES, 0, 36);

            requestAnimationFrame(updateAndRender);
        }
        requestAnimationFrame(updateAndRender);
    </script>
</body>

</html>