<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Red Alert Clone V5 (Active Braking)</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            font-family: 'Courier New', Courier, monospace;
        }

        #game-container {
            display: flex;
            height: 100vh;
        }

        #canvas-container {
            flex-grow: 1;
            position: relative;
            cursor: crosshair;
        }

        canvas {
            display: block;
            background-color: #2b3a42;
        }

        #sidebar {
            width: 250px;
            background: #1a1a1a;
            border-left: 4px solid #4a4a4a;
            display: flex;
            flex-direction: column;
            padding: 10px;
            color: #00ff00;
            user-select: none;
        }

        .title {
            text-align: center;
            font-weight: bold;
            border-bottom: 2px solid #555;
            margin-bottom: 20px;
            padding-bottom: 10px;
        }

        .radar {
            width: 100%;
            height: 200px;
            background: #000;
            border: 2px solid #005500;
            margin-bottom: 20px;
        }

        .build-btn {
            background: #333;
            border: 2px solid #555;
            color: #ddd;
            padding: 15px;
            margin-bottom: 10px;
            cursor: pointer;
            text-align: center;
            font-weight: bold;
            transition: 0.2s;
        }

        .build-btn:hover {
            background: #555;
            border-color: #ddd;
        }

        .build-btn:active {
            background: #222;
        }

        #selection-box {
            position: absolute;
            border: 1px solid #00ff00;
            background-color: rgba(0, 255, 0, 0.2);
            display: none;
            pointer-events: none;
        }
    </style>
</head>

<body>

    <div id="game-container">
        <div id="canvas-container">
            <canvas id="gameCanvas"></canvas>
            <div id="selection-box"></div>
        </div>
        <div id="sidebar">
            <div class="title">RED ALERT v5<br><span style="font-size:10px; color:magenta">ACTIVE BRAKING</span></div>
            <div class="radar"></div>
            <div class="build-btn" onclick="trySpawn('tank')">BUILD TANK ($800)</div>
            <div class="build-btn" onclick="trySpawn('soldier')">BUILD RIFLE ($100)</div>
            <div style="font-size: 11px; color: #888; margin-top: auto;">
                Changes:<br>- Inertia increased (low drag)<br>- Calculated stopping distance<br>- Visual Brake Lights
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const selectionBox = document.getElementById('selection-box');

        function resize() {
            canvas.width = document.getElementById('canvas-container').offsetWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        // --- Utils ---
        function normalizeAngle(angle) {
            while (angle > Math.PI) angle -= Math.PI * 2;
            while (angle < -Math.PI) angle += Math.PI * 2;
            return angle;
        }

        function distance(x1, y1, x2, y2) {
            return Math.hypot(x2 - x1, y2 - y1);
        }

        // --- Game State ---
        const units = [];
        const particles = [];
        let selectedUnits = [];

        let isDragging = false;
        let startX, startY;

        // --- Classes ---

        class Unit {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.selected = false;

                // Destination
                this.targetX = x;
                this.targetY = y;

                // Physics State
                this.angle = Math.random() * Math.PI * 2;
                this.currentSpeed = 0;
                this.isBraking = false; // Visual state for lights

                // Specs
                if (type === 'tank') {
                    this.color = '#ccaa00';
                    this.radius = 28;

                    // Physics Constants
                    this.maxSpeed = 3.0;       // Higher top speed
                    this.acceleration = 0.08;  // Engine power
                    this.brakingForce = 0.15;  // Strong brakes
                    this.friction = 0.98;      // Low Drag (High Inertia)
                    this.turnSpeed = 0.04;
                    this.health = 100;
                } else {
                    this.color = '#aaaaaa';
                    this.radius = 10;
                    this.maxSpeed = 1.8;
                    this.acceleration = 0.2;
                    this.brakingForce = 0.3;
                    this.friction = 0.85; // Soldiers stop faster
                    this.turnSpeed = 0.3;
                    this.health = 30;
                }
            }

            update() {
                const dist = distance(this.x, this.y, this.targetX, this.targetY);

                // 1. Steering
                const targetAngle = Math.atan2(this.targetY - this.y, this.targetX - this.x);
                let diff = normalizeAngle(targetAngle - this.angle);

                // Rotate
                if (Math.abs(diff) > this.turnSpeed && dist > 5) {
                    this.angle += Math.sign(diff) * this.turnSpeed;
                } else if (dist > 5) {
                    this.angle = targetAngle;
                }

                // 2. Physics Decision Making
                this.isBraking = false;
                let throttle = 0;

                if (dist < 5) {
                    // Arrived
                    this.isBraking = true;
                    this.currentSpeed *= 0.8; // Hard stop
                    if (this.currentSpeed < 0.1) this.currentSpeed = 0;
                } else {
                    // Calculate Stopping Distance needed: d = (v^2) / (2 * brakingForce)
                    // We add a safety margin (+10px)
                    const stoppingDist = (this.currentSpeed * this.currentSpeed) / (2 * this.brakingForce);

                    // Condition A: Arrival Braking
                    // If we don't brake now, we will overshoot.
                    if (dist < stoppingDist + 20) {
                        this.isBraking = true;
                    }

                    // Condition B: Cornering Braking
                    // If the turn is sharp (> 45 degrees), we must slow down.
                    else if (Math.abs(diff) > Math.PI / 4) {
                        this.isBraking = true;
                    }

                    // Condition C: Accelerate
                    // Only if we are not braking and facing roughly the right way
                    else {
                        throttle = 1;
                    }
                }

                // 3. Apply Forces
                if (this.isBraking) {
                    // Active Braking: Subtract from speed linearly
                    if (this.currentSpeed > 0) {
                        this.currentSpeed -= this.brakingForce;
                        if (this.currentSpeed < 0) this.currentSpeed = 0;
                    }
                } else {
                    // Accelerate
                    if (this.currentSpeed < this.maxSpeed) {
                        this.currentSpeed += this.acceleration * throttle;
                    }
                }

                // 4. Drag (Air resistance / Friction)
                // Even when accelerating, drag exists, but it's low (0.98)
                this.currentSpeed *= this.friction;

                // 5. Move
                this.x += Math.cos(this.angle) * this.currentSpeed;
                this.y += Math.sin(this.angle) * this.currentSpeed;

                // Dust
                if (this.currentSpeed > 0.5 && this.type === 'tank' && !this.isBraking && Math.random() > 0.8) {
                    particles.push(new Dust(
                        this.x - Math.cos(this.angle) * 15,
                        this.y - Math.sin(this.angle) * 15
                    ));
                }
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);

                if (this.selected) {
                    ctx.strokeStyle = '#00ff00';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius + 2, 0, Math.PI * 2);
                    ctx.stroke();

                    ctx.fillStyle = '#00ff00';
                    ctx.fillRect(-12, -this.radius - 8, 24 * (this.health / (this.type === 'tank' ? 100 : 30)), 3);
                }

                ctx.rotate(this.angle);

                if (this.type === 'tank') {
                    // Shadow
                    ctx.fillStyle = 'rgba(0,0,0,0.5)';
                    ctx.fillRect(-15, -10, 36, 28);

                    // Body
                    ctx.fillStyle = this.color;
                    ctx.fillRect(-18, -14, 36, 28);

                    // Brake Lights (The visual feedback)
                    if (this.isBraking) {
                        ctx.fillStyle = '#ff0000';
                        ctx.shadowColor = '#ff0000';
                        ctx.shadowBlur = 10;
                        // Left light
                        ctx.fillRect(-18, -12, 2, 6);
                        // Right light
                        ctx.fillRect(-18, 6, 2, 6);
                        ctx.shadowBlur = 0; // reset
                    }

                    // Tracks
                    ctx.fillStyle = '#080808';
                    ctx.fillRect(-18, -16, 36, 4);
                    ctx.fillRect(-18, 12, 36, 4);

                    // Detail
                    ctx.fillStyle = '#333';
                    for (let i = -16; i < 16; i += 4) {
                        ctx.fillRect(i, -16, 1, 4);
                        ctx.fillRect(i, 12, 1, 4);
                    }

                    // Turret
                    ctx.fillStyle = '#997700';
                    ctx.beginPath();
                    ctx.arc(-2, 0, 11, 0, Math.PI * 2);
                    ctx.fill();

                    // Barrel
                    ctx.strokeStyle = '#886600';
                    ctx.lineWidth = 6;
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(26, 0);
                    ctx.stroke();
                } else {
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(0, 0, 6, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#222';
                    ctx.fillRect(0, -2, 10, 4);
                }
                ctx.restore();
            }

            setDestination(x, y) {
                const spread = 30;
                this.targetX = x + (Math.random() * spread - spread / 2);
                this.targetY = y + (Math.random() * spread - spread / 2);
            }
        }

        class Dust {
            constructor(x, y) {
                this.x = x + (Math.random() * 10 - 5);
                this.y = y + (Math.random() * 10 - 5);
                this.size = Math.random() * 5 + 2;
                this.life = 1.0;
            }
            update() {
                this.life -= 0.05;
                this.size += 0.2;
            }
            draw() {
                ctx.fillStyle = `rgba(150, 140, 100, ${this.life * 0.3})`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        class MoveMarker {
            constructor(x, y) { this.x = x; this.y = y; this.life = 20; }
            update() { this.life--; }
            draw() {
                if (this.life < 0) return;
                ctx.strokeStyle = '#00ff00';
                ctx.beginPath();
                ctx.moveTo(this.x - 5, this.y - 5); ctx.lineTo(this.x + 5, this.y + 5);
                ctx.moveTo(this.x + 5, this.y - 5); ctx.lineTo(this.x - 5, this.y + 5);
                ctx.stroke();
            }
        }

        // --- Physics Engine ---

        function resolveCollisions() {
            const iterations = 2;
            for (let k = 0; k < iterations; k++) {
                for (let i = 0; i < units.length; i++) {
                    for (let j = i + 1; j < units.length; j++) {
                        const u1 = units[i];
                        const u2 = units[j];

                        const dx = u1.x - u2.x;
                        const dy = u1.y - u2.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const minDist = u1.radius + u2.radius;

                        if (dist < minDist) {
                            const overlap = minDist - dist;
                            const angle = Math.atan2(dy, dx);

                            // Heavier, stronger push
                            const force = overlap * 0.1;

                            const pushX = Math.cos(angle) * force;
                            const pushY = Math.sin(angle) * force;

                            u1.x += pushX;
                            u1.y += pushY;
                            u2.x -= pushX;
                            u2.y -= pushY;

                            // Collision saps speed (Momentum loss)
                            u1.currentSpeed *= 0.95;
                            u2.currentSpeed *= 0.95;
                        }
                    }
                }
            }
        }

        function trySpawn(type) {
            const spawnAreaX = 150;
            const spawnAreaY = canvas.height / 2;
            const range = 100;
            const tempRadius = (type === 'tank') ? 28 : 10;
            let bestX = 0, bestY = 0;
            let foundSpot = false;

            for (let i = 0; i < 50; i++) {
                const rx = spawnAreaX + (Math.random() * range * 2 - range);
                const ry = spawnAreaY + (Math.random() * range * 2 - range);
                let collision = false;
                for (let u of units) {
                    if (distance(u.x, u.y, rx, ry) < u.radius + tempRadius + 5) {
                        collision = true; break;
                    }
                }
                if (!collision) { bestX = rx; bestY = ry; foundSpot = true; break; }
            }
            if (foundSpot) units.push(new Unit(bestX, bestY, type));
        }

        // --- Inputs ---

        window.addEventListener('contextmenu', e => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const mx = e.clientX - rect.left;
            const my = e.clientY - rect.top;
            particles.push(new MoveMarker(mx, my));
            units.forEach(u => { if (u.selected) u.setDestination(mx, my); });
        });

        const container = document.getElementById('canvas-container');
        container.addEventListener('mousedown', e => {
            if (e.button !== 0) return;
            const rect = canvas.getBoundingClientRect();
            startX = e.clientX - rect.left;
            startY = e.clientY - rect.top;
            isDragging = true;
            selectionBox.style.display = 'block';
            selectionBox.style.left = startX + 'px'; selectionBox.style.top = startY + 'px';
            selectionBox.style.width = '0px'; selectionBox.style.height = '0px';
        });

        container.addEventListener('mousemove', e => {
            if (!isDragging) return;
            const rect = canvas.getBoundingClientRect();
            const curX = e.clientX - rect.left;
            const curY = e.clientY - rect.top;
            const w = curX - startX;
            const h = curY - startY;
            selectionBox.style.width = Math.abs(w) + 'px';
            selectionBox.style.height = Math.abs(h) + 'px';
            selectionBox.style.left = (w < 0 ? curX : startX) + 'px';
            selectionBox.style.top = (h < 0 ? curY : startY) + 'px';
        });

        container.addEventListener('mouseup', e => {
            if (e.button !== 0) return;
            isDragging = false;
            selectionBox.style.display = 'none';
            const rect = canvas.getBoundingClientRect();
            const endX = e.clientX - rect.left;
            const endY = e.clientY - rect.top;
            const x1 = Math.min(startX, endX); const y1 = Math.min(startY, endY);
            const x2 = Math.max(startX, endX); const y2 = Math.max(startY, endY);

            units.forEach(u => u.selected = false);
            selectedUnits = [];

            if (Math.abs(x2 - x1) > 5 || Math.abs(y2 - y1) > 5) {
                units.forEach(u => {
                    if (u.x > x1 && u.x < x2 && u.y > y1 && u.y < y2) {
                        u.selected = true; selectedUnits.push(u);
                    }
                });
            } else {
                units.forEach(u => {
                    if (distance(u.x, u.y, endX, endY) < u.radius + 5) {
                        u.selected = true; selectedUnits.push(u);
                    }
                });
            }
        });

        // --- Loop ---

        function loop() {
            ctx.fillStyle = '#2b3a42';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Grid
            ctx.strokeStyle = '#35454d';
            ctx.lineWidth = 1;
            ctx.beginPath();
            for (let x = 0; x < canvas.width; x += 50) { ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); }
            for (let y = 0; y < canvas.height; y += 50) { ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); }
            ctx.stroke();

            units.forEach(u => u.update());
            resolveCollisions();

            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].update();
                particles[i].draw();
                if (particles[i].life <= 0) particles.splice(i, 1);
            }

            units.forEach(u => u.draw());

            requestAnimationFrame(loop);
        }

        trySpawn('tank'); trySpawn('tank'); trySpawn('soldier');
        loop();

    </script>
</body>

</html>