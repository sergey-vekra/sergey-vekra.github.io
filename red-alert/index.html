<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Red Alert Clone V9 (2-Finger Pan)</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            font-family: 'Courier New', Courier, monospace;
            touch-action: none;
            /* Critical: Disables browser zoom/scroll */
        }

        #game-container {
            display: flex;
            height: 100vh;
            width: 100vw;
        }

        #canvas-container {
            flex: 1;
            position: relative;
            cursor: crosshair;
            overflow: hidden;
        }

        canvas {
            display: block;
            background-color: #2b3a42;
        }

        #ui-layer {
            position: absolute;
            top: 10px;
            left: 10px;
            pointer-events: none;
            color: white;
            text-shadow: 1px 1px 0 #000;
        }

        #sidebar {
            width: 250px;
            background: #1a1a1a;
            border-left: 4px solid #4a4a4a;
            z-index: 10;
            display: flex;
            flex-direction: column;
            padding: 10px;
            color: #00ff00;
            user-select: none;
        }

        .title {
            text-align: center;
            font-weight: bold;
            border-bottom: 2px solid #555;
            margin-bottom: 20px;
            padding-bottom: 10px;
        }

        .radar {
            width: 250px;
            height: 200px;
            background: #000;
            border: 2px solid #005500;
            margin-bottom: 20px;
            position: relative;
            overflow: hidden;
            cursor: crosshair;
        }

        .radar-dot {
            position: absolute;
            width: 2px;
            height: 2px;
            background: #0f0;
            pointer-events: none;
        }

        .radar-view {
            position: absolute;
            border: 1px solid white;
            pointer-events: none;
        }

        .build-btn {
            background: #333;
            border: 2px solid #555;
            color: #ddd;
            padding: 15px;
            margin-bottom: 10px;
            cursor: pointer;
            text-align: center;
            font-weight: bold;
            transition: 0.2s;
        }

        .build-btn:hover {
            background: #555;
            border-color: #ddd;
        }

        .build-btn:active {
            background: #222;
        }

        #selection-box {
            position: absolute;
            border: 1px solid #00ff00;
            background-color: rgba(0, 255, 0, 0.2);
            display: none;
            pointer-events: none;
        }
    </style>
</head>

<body>

    <div id="game-container">
        <div id="canvas-container">
            <canvas id="gameCanvas"></canvas>
            <div id="selection-box"></div>
            <div id="ui-layer">
                <h2 style="margin:0">SECTOR 7G</h2>
                <small>Touch: 2-Finger Pan | 1-Finger Select/Move</small>
            </div>
        </div>
        <div id="sidebar" id="sidebar">
            <div class="title">RED ALERT v9<br><span style="font-size:10px; color:lime">TOUCH UPDATE</span></div>
            <div class="radar" id="radar"></div>
            <div class="build-btn" onclick="world.trySpawn('tank')">BUILD TANK ($800)</div>
            <div class="build-btn" onclick="world.trySpawn('soldier')">BUILD RIFLE ($100)</div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const selectionBox = document.getElementById('selection-box');
        const radar = document.getElementById('radar');

        const WORLD_W = 3000;
        const WORLD_H = 3000;
        const GRID_SIZE = 50;

        function resize() {
            canvas.width = document.getElementById('canvas-container').offsetWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        // --- Math Utils ---
        const normalizeAngle = a => { while (a > Math.PI) a -= Math.PI * 2; while (a < -Math.PI) a += Math.PI * 2; return a; };
        const dist = (x1, y1, x2, y2) => Math.hypot(x2 - x1, y2 - y1);
        const clamp = (val, min, max) => Math.min(Math.max(val, min), max);

        // --- Pathfinding ---
        class Grid {
            constructor(width, height, cellSize) {
                this.cellSize = cellSize;
                this.cols = Math.ceil(width / cellSize);
                this.rows = Math.ceil(height / cellSize);
                this.grid = [];
                for (let y = 0; y < this.rows; y++) {
                    this.grid[y] = [];
                    for (let x = 0; x < this.cols; x++) this.grid[y][x] = 0;
                }
            }
            markObstacle(x, y, radius) {
                const startCol = Math.floor((x - radius) / this.cellSize);
                const endCol = Math.floor((x + radius) / this.cellSize);
                const startRow = Math.floor((y - radius) / this.cellSize);
                const endRow = Math.floor((y + radius) / this.cellSize);

                for (let r = startRow; r <= endRow; r++) {
                    for (let c = startCol; c <= endCol; c++) {
                        if (r >= 0 && r < this.rows && c >= 0 && c < this.cols) this.grid[r][c] = 1;
                    }
                }
            }
            isBlocked(x, y) {
                const c = Math.floor(x / this.cellSize);
                const r = Math.floor(y / this.cellSize);
                if (r >= 0 && r < this.rows && c >= 0 && c < this.cols) return this.grid[r][c] === 1;
                return true;
            }
            findPath(startX, startY, endX, endY) {
                const startNode = { x: Math.floor(startX / this.cellSize), y: Math.floor(startY / this.cellSize) };
                const endNode = { x: Math.floor(endX / this.cellSize), y: Math.floor(endY / this.cellSize) };

                if (startNode.x < 0 || startNode.x >= this.cols || startNode.y < 0 || startNode.y >= this.rows) return [];
                if (endNode.x < 0 || endNode.x >= this.cols || endNode.y < 0 || endNode.y >= this.rows) return [];
                if (this.grid[endNode.y][endNode.x] === 1) return [];

                const openSet = [];
                const closedSet = new Set();
                openSet.push({ ...startNode, g: 0, h: 0, f: 0, parent: null });

                while (openSet.length > 0) {
                    let lowestIndex = 0;
                    for (let i = 1; i < openSet.length; i++) if (openSet[i].f < openSet[lowestIndex].f) lowestIndex = i;
                    let current = openSet[lowestIndex];

                    if (current.x === endNode.x && current.y === endNode.y) {
                        let path = [];
                        let temp = current;
                        while (temp.parent) {
                            path.push({ x: temp.x * this.cellSize + this.cellSize / 2, y: temp.y * this.cellSize + this.cellSize / 2 });
                            temp = temp.parent;
                        }
                        return path.reverse();
                    }

                    openSet.splice(lowestIndex, 1);
                    closedSet.add(`${current.x},${current.y}`);

                    const neighbors = [{ x: 0, y: -1 }, { x: 0, y: 1 }, { x: -1, y: 0 }, { x: 1, y: 0 }, { x: -1, y: -1 }, { x: 1, y: -1 }, { x: -1, y: 1 }, { x: 1, y: 1 }];

                    for (let neighbor of neighbors) {
                        const nx = current.x + neighbor.x;
                        const ny = current.y + neighbor.y;
                        if (nx < 0 || ny < 0 || nx >= this.cols || ny >= this.rows) continue;
                        if (this.grid[ny][nx] === 1) continue;
                        if (closedSet.has(`${nx},${ny}`)) continue;

                        const distCost = (Math.abs(neighbor.x) + Math.abs(neighbor.y) === 2) ? 1.4 : 1.0;
                        const tempG = current.g + distCost;

                        let neighborNode = openSet.find(n => n.x === nx && n.y === ny);
                        if (!neighborNode) {
                            neighborNode = { x: nx, y: ny, g: tempG, h: 0, f: 0, parent: current };
                            neighborNode.h = Math.abs(nx - endNode.x) + Math.abs(ny - endNode.y);
                            neighborNode.f = neighborNode.g + neighborNode.h;
                            openSet.push(neighborNode);
                        } else if (tempG < neighborNode.g) {
                            neighborNode.g = tempG;
                            neighborNode.f = neighborNode.g + neighborNode.h;
                            neighborNode.parent = current;
                        }
                    }
                }
                return [];
            }
        }

        // --- Camera ---
        class Camera {
            constructor() {
                this.x = 1000; this.y = 1000;
                this.velX = 0; this.velY = 0;
                this.target = null;
                this.friction = 0.85;
            }
            update() {
                if (this.target) {
                    const tx = this.target.x - canvas.width / 2;
                    const ty = this.target.y - canvas.height / 2;
                    this.x += (tx - this.x) * 0.1;
                    this.y += (ty - this.y) * 0.1;
                } else {
                    this.x += this.velX;
                    this.y += this.velY;
                    this.velX *= this.friction;
                    this.velY *= this.friction;
                }
                if (this.x < 0) { this.x = 0; this.velX = 0; }
                if (this.y < 0) { this.y = 0; this.velY = 0; }
                if (this.x > WORLD_W - canvas.width) { this.x = WORLD_W - canvas.width; this.velX = 0; }
                if (this.y > WORLD_H - canvas.height) { this.y = WORLD_H - canvas.height; this.velY = 0; }
            }
        }

        // --- Objects ---
        class Obstacle {
            constructor(x, y, r, type) {
                this.x = x; this.y = y; this.radius = r; this.type = type;
                if (type === 'rock' || type === 'lake') {
                    this.points = [];
                    const sides = (type === 'lake') ? 8 + Math.random() * 5 : 5 + Math.random() * 3;
                    for (let i = 0; i < sides; i++) {
                        const angle = (i / sides) * Math.PI * 2;
                        const variance = (type === 'lake') ? 0.6 : 0.4;
                        const rad = r * (1 - variance + Math.random() * variance);
                        this.points.push({ x: Math.cos(angle) * rad, y: Math.sin(angle) * rad });
                    }
                }
            }
            draw() {
                ctx.translate(this.x, this.y);
                if (this.type === 'tree') {
                    ctx.fillStyle = '#1a331a'; ctx.beginPath(); ctx.arc(3, 3, this.radius, 0, Math.PI * 2); ctx.fill();
                    ctx.fillStyle = '#2d5a2d'; ctx.beginPath(); ctx.arc(0, 0, this.radius, 0, Math.PI * 2); ctx.fill();
                    ctx.fillStyle = '#3e7a3e'; ctx.beginPath(); ctx.arc(-this.radius * 0.3, -this.radius * 0.3, this.radius * 0.4, 0, Math.PI * 2); ctx.fill();
                } else if (this.type === 'rock') {
                    ctx.fillStyle = '#555'; ctx.beginPath(); ctx.moveTo(this.points[0].x, this.points[0].y);
                    this.points.forEach(p => ctx.lineTo(p.x, p.y));
                    ctx.closePath(); ctx.fill(); ctx.strokeStyle = '#666'; ctx.stroke();
                } else if (this.type === 'lake') {
                    ctx.fillStyle = '#346b85'; ctx.beginPath(); ctx.moveTo(this.points[0].x, this.points[0].y);
                    this.points.forEach(p => ctx.lineTo(p.x, p.y));
                    ctx.closePath(); ctx.fill(); ctx.strokeStyle = '#5a9bc0'; ctx.lineWidth = 2; ctx.stroke();
                } else {
                    ctx.fillStyle = '#111'; ctx.fillRect(-this.radius, -this.radius, this.radius * 2, this.radius * 2);
                    ctx.fillStyle = '#444'; ctx.fillRect(-this.radius + 2, -this.radius + 2, this.radius * 2 - 4, this.radius * 2 - 4);
                }
                ctx.translate(-this.x, -this.y);
            }
        }

        class Unit {
            constructor(x, y, type) {
                this.x = x; this.y = y; this.type = type; this.selected = false;
                this.angle = Math.random() * Math.PI * 2;
                this.currentSpeed = 0; this.isBraking = false;
                this.path = []; this.currentTarget = null;

                if (type === 'tank') {
                    this.color = '#ccaa00';
                    this.radius = 35; // Visual Radius
                    this.collisionRadius = 38; // Physics Radius
                    this.maxSpeed = 3.0; this.acceleration = 0.08; this.brakingForce = 0.15;
                    this.friction = 0.98; this.turnSpeed = 0.04; this.health = 100;
                    this.mass = 10;
                } else {
                    this.color = '#aaaaaa';
                    this.radius = 12;
                    this.collisionRadius = 15;
                    this.maxSpeed = 1.8; this.acceleration = 0.2; this.brakingForce = 0.3;
                    this.friction = 0.85; this.turnSpeed = 0.3; this.health = 30;
                    this.mass = 1;
                }
            }
            update() {
                if (this.path.length > 0) {
                    const nextPoint = this.path[0];
                    if (dist(this.x, this.y, nextPoint.x, nextPoint.y) < 30) this.path.shift();
                    else this.driveTo(nextPoint.x, nextPoint.y);
                } else if (this.currentTarget) {
                    this.driveTo(this.currentTarget.x, this.currentTarget.y);
                } else {
                    this.currentSpeed *= this.friction;
                    this.x += Math.cos(this.angle) * this.currentSpeed;
                    this.y += Math.sin(this.angle) * this.currentSpeed;
                }
                if (this.currentSpeed > 0.5 && this.type === 'tank' && !this.isBraking && Math.random() > 0.8) {
                    world.particles.push(new Dust(this.x - Math.cos(this.angle) * 15, this.y - Math.sin(this.angle) * 15));
                }
            }

            driveTo(tx, ty) {
                const d = dist(this.x, this.y, tx, ty);
                const targetAngle = Math.atan2(ty - this.y, tx - this.x);
                let diff = normalizeAngle(targetAngle - this.angle);

                if (Math.abs(diff) > this.turnSpeed && d > 5) this.angle += Math.sign(diff) * this.turnSpeed;
                else if (d > 5) this.angle = targetAngle;

                this.isBraking = false;
                let throttle = 0;
                const isFinalTarget = (this.path.length === 0);
                const stoppingDist = (this.currentSpeed * this.currentSpeed) / (2 * this.brakingForce);

                if (isFinalTarget && (d < 5 || d < stoppingDist + 20)) this.isBraking = true;
                else if (Math.abs(diff) > Math.PI / 4) this.isBraking = true;
                else throttle = 1;

                if (this.isBraking) {
                    if (this.currentSpeed > 0) this.currentSpeed -= this.brakingForce;
                    if (this.currentSpeed < 0) this.currentSpeed = 0;
                } else if (this.currentSpeed < this.maxSpeed) {
                    this.currentSpeed += this.acceleration * throttle;
                }

                this.currentSpeed *= this.friction;
                this.x += Math.cos(this.angle) * this.currentSpeed;
                this.y += Math.sin(this.angle) * this.currentSpeed;
            }

            draw() {
                if (this.x < camera.x - 50 || this.x > camera.x + canvas.width + 50 ||
                    this.y < camera.y - 50 || this.y > camera.y + canvas.height + 50) return;

                if (this.selected && this.path.length > 0) {
                    ctx.strokeStyle = 'rgba(0, 255, 0, 0.5)'; ctx.lineWidth = 2; ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    this.path.forEach(p => ctx.lineTo(p.x, p.y));
                    if (this.currentTarget) ctx.lineTo(this.currentTarget.x, this.currentTarget.y);
                    ctx.stroke();
                }

                ctx.translate(this.x, this.y);
                if (this.selected) {
                    ctx.strokeStyle = '#00ff00'; ctx.lineWidth = 1; ctx.beginPath();
                    ctx.arc(0, 0, this.radius, 0, Math.PI * 2); ctx.stroke();
                    ctx.fillStyle = '#00ff00'; ctx.fillRect(-12, -this.radius - 8, 24 * (this.health / 100), 3);
                }
                ctx.rotate(this.angle);
                if (this.type === 'tank') {
                    ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.fillRect(-17, -12, 40, 32);
                    ctx.fillStyle = this.color; ctx.fillRect(-20, -16, 40, 32);
                    ctx.fillStyle = '#080808'; ctx.fillRect(-20, -18, 40, 4); ctx.fillRect(-20, 14, 40, 4);
                    if (this.isBraking) {
                        ctx.fillStyle = '#ff0000'; ctx.shadowColor = '#ff0000'; ctx.shadowBlur = 10;
                        ctx.fillRect(-20, -14, 3, 6); ctx.fillRect(-20, 8, 3, 6); ctx.shadowBlur = 0;
                    }
                    ctx.fillStyle = '#997700'; ctx.beginPath(); ctx.arc(-2, 0, 13, 0, Math.PI * 2); ctx.fill();
                    ctx.strokeStyle = '#886600'; ctx.lineWidth = 7; ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(30, 0); ctx.stroke();
                } else {
                    ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(0, 0, 8, 0, Math.PI * 2); ctx.fill();
                    ctx.fillStyle = '#222'; ctx.fillRect(0, -3, 12, 6);
                }
                ctx.rotate(-this.angle);
                ctx.translate(-this.x, -this.y);
            }

            setPath(path, finalX, finalY) {
                const spread = 80;
                this.currentTarget = {
                    x: finalX + (Math.random() * spread - spread / 2),
                    y: finalY + (Math.random() * spread - spread / 2)
                };
                this.path = path;
            }
        }

        class Dust {
            constructor(x, y) { this.x = x; this.y = y; this.size = Math.random() * 5 + 2; this.life = 1.0; }
            update() { this.life -= 0.05; this.size += 0.2; }
            draw() {
                ctx.fillStyle = `rgba(150, 140, 100, ${this.life * 0.3})`;
                ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill();
            }
        }
        class MoveMarker {
            constructor(x, y) { this.x = x; this.y = y; this.life = 20; }
            update() { this.life--; }
            draw() {
                ctx.strokeStyle = '#00ff00'; ctx.lineWidth = 2; ctx.beginPath();
                ctx.moveTo(this.x - 5, this.y - 5); ctx.lineTo(this.x + 5, this.y + 5);
                ctx.moveTo(this.x + 5, this.y - 5); ctx.lineTo(this.x - 5, this.y + 5); ctx.stroke();
            }
        }

        // --- World Engine ---
        class World {
            constructor() {
                this.grid = new Grid(WORLD_W, WORLD_H, GRID_SIZE);
                this.units = []; this.obstacles = []; this.particles = [];
                this.generateMap();
            }

            generateMap() {
                for (let i = 0; i < 40; i++) {
                    const cx = Math.random() * WORLD_W; const cy = Math.random() * WORLD_H;
                    for (let j = 0; j < 10; j++) {
                        const tx = cx + Math.random() * 200 - 100; const ty = cy + Math.random() * 200 - 100;
                        this.addObstacle(new Obstacle(tx, ty, 15 + Math.random() * 15, 'tree'));
                    }
                }
                for (let i = 0; i < 30; i++) this.addObstacle(new Obstacle(Math.random() * WORLD_W, Math.random() * WORLD_H, 30 + Math.random() * 30, 'rock'));
                for (let i = 0; i < 8; i++) this.addObstacle(new Obstacle(Math.random() * WORLD_W, Math.random() * WORLD_H, 80 + Math.random() * 60, 'lake'));
                for (let i = 0; i < 15; i++) this.addObstacle(new Obstacle(Math.random() * WORLD_W, Math.random() * WORLD_H, 60 + Math.random() * 20, 'building'));

                this.obstacles = this.obstacles.filter(o => dist(o.x, o.y, 1000, 1000) > 300);
                this.obstacles.forEach(o => this.grid.markObstacle(o.x, o.y, o.radius));
            }

            addObstacle(obs) { this.obstacles.push(obs); }

            resolveCollisions() {
                const iterations = 3;
                for (let k = 0; k < iterations; k++) {
                    for (let i = 0; i < this.units.length; i++) {
                        for (let j = i + 1; j < this.units.length; j++) {
                            const u1 = this.units[i]; const u2 = this.units[j];
                            const d = dist(u1.x, u1.y, u2.x, u2.y);
                            const minD = u1.collisionRadius + u2.collisionRadius;

                            if (d < minD && d > 0) {
                                const overlap = minD - d;
                                const angle = Math.atan2(u1.y - u2.y, u1.x - u2.x);
                                const totalMass = u1.mass + u2.mass;
                                const m1 = u2.mass / totalMass; const m2 = u1.mass / totalMass;
                                const moveX = Math.cos(angle) * overlap; const moveY = Math.sin(angle) * overlap;

                                u1.x += moveX * m1; u1.y += moveY * m1;
                                u2.x -= moveX * m2; u2.y -= moveY * m2;
                                u1.currentSpeed *= 0.9; u2.currentSpeed *= 0.9;
                            }
                        }
                    }
                    for (let u of this.units) {
                        for (let o of this.obstacles) {
                            const d = dist(u.x, u.y, o.x, o.y);
                            const minD = u.collisionRadius + o.radius;
                            if (d < minD) {
                                const overlap = minD - d;
                                const angle = Math.atan2(u.y - o.y, u.x - o.x);
                                u.x += Math.cos(angle) * overlap;
                                u.y += Math.sin(angle) * overlap;
                                u.currentSpeed *= 0.5;
                            }
                        }
                    }
                }
            }

            trySpawn(type) {
                const range = 200;
                let bestX = 0, bestY = 0, found = false;
                for (let i = 0; i < 20; i++) {
                    const rx = camera.x + canvas.width / 2 + (Math.random() * range - range / 2);
                    const ry = camera.y + canvas.height / 2 + (Math.random() * range - range / 2);
                    if (!this.grid.isBlocked(rx, ry)) { bestX = rx; bestY = ry; found = true; break; }
                }
                if (found) this.units.push(new Unit(bestX, bestY, type));
            }

            update() {
                this.units.forEach(u => u.update());
                this.resolveCollisions();
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    this.particles[i].update();
                    if (this.particles[i].life <= 0) this.particles.splice(i, 1);
                }
            }

            draw() {
                ctx.strokeStyle = '#35454d'; ctx.lineWidth = 1; ctx.beginPath();
                const startX = Math.floor(camera.x / 100) * 100;
                const startY = Math.floor(camera.y / 100) * 100;
                for (let x = startX; x < camera.x + canvas.width; x += 100) { ctx.moveTo(x, camera.y); ctx.lineTo(x, camera.y + canvas.height); }
                for (let y = startY; y < camera.y + canvas.height; y += 100) { ctx.moveTo(camera.x, y); ctx.lineTo(camera.x + canvas.width, y); }
                ctx.stroke();

                ctx.strokeStyle = '#ff0000'; ctx.lineWidth = 5; ctx.strokeRect(0, 0, WORLD_W, WORLD_H);

                this.obstacles.forEach(o => {
                    if (o.x > camera.x - 100 && o.x < camera.x + canvas.width + 100 &&
                        o.y > camera.y - 100 && o.y < camera.y + canvas.height + 100) o.draw();
                });
                this.particles.forEach(p => p.draw());
                this.units.forEach(u => u.draw());
            }

            updateRadar() {
                radar.innerHTML = '';
                const sx = 250 / WORLD_W; const sy = 200 / WORLD_H;
                const vDiv = document.createElement('div');
                vDiv.className = 'radar-view';
                vDiv.style.left = (camera.x * sx) + 'px'; vDiv.style.top = (camera.y * sy) + 'px';
                vDiv.style.width = (canvas.width * sx) + 'px'; vDiv.style.height = (canvas.height * sy) + 'px';
                radar.appendChild(vDiv);
                this.units.forEach(u => {
                    const d = document.createElement('div'); d.className = 'radar-dot';
                    if (u.type === 'tank') d.style.background = 'gold';
                    d.style.left = (u.x * sx) + 'px'; d.style.top = (u.y * sy) + 'px';
                    radar.appendChild(d);
                });
            }
        }

        // --- Input Handling ---
        const world = new World();
        const camera = new Camera();

        let pointerDown = false;
        let isRightClick = false;
        let isTwoFinger = false;

        let startX = 0, startY = 0; // For Selection Box / Tap detection
        let lastPanX = 0, lastPanY = 0; // For Panning
        let hasMoved = false;

        function getTouchCenter(e) {
            if (e.touches.length >= 2) {
                return {
                    x: (e.touches[0].clientX + e.touches[1].clientX) / 2,
                    y: (e.touches[0].clientY + e.touches[1].clientY) / 2
                };
            }
            return { x: e.touches[0].clientX, y: e.touches[0].clientY };
        }

        function handleStart(e) {
            if (e.target !== canvas) return;
            pointerDown = true;
            hasMoved = false;
            camera.target = null;

            // Touch Logic
            if (e.type === 'touchstart') {
                if (e.touches.length === 2) {
                    // 2 Fingers = Pan Mode
                    isTwoFinger = true;
                    const center = getTouchCenter(e);
                    lastPanX = center.x;
                    lastPanY = center.y;
                    selectionBox.style.display = 'none'; // Cancel any selection
                } else if (e.touches.length === 1) {
                    // 1 Finger = Select Mode (Tap or Box)
                    isTwoFinger = false;
                    startX = e.touches[0].clientX;
                    startY = e.touches[0].clientY;

                    selectionBox.style.display = 'block';
                    selectionBox.style.left = startX + 'px';
                    selectionBox.style.top = startY + 'px';
                    selectionBox.style.width = '0'; selectionBox.style.height = '0';
                }
            }
            // Mouse Logic
            else {
                isTwoFinger = false;
                startX = e.clientX;
                startY = e.clientY;
                lastPanX = e.clientX;
                lastPanY = e.clientY;
                isRightClick = (e.button === 2);

                if (isRightClick) {
                    // Right Mouse Down = Box Select
                    selectionBox.style.display = 'block';
                    selectionBox.style.left = startX + 'px';
                    selectionBox.style.top = startY + 'px';
                    selectionBox.style.width = '0'; selectionBox.style.height = '0';
                } else {
                    // Left Mouse Down = Pan
                    camera.velX = 0; camera.velY = 0;
                }
            }
        }

        function handleMove(e) {
            if (!pointerDown) return;

            // Check threshold for "Tap" vs "Drag"
            let curX, curY;
            if (e.type.startsWith('touch')) {
                const center = getTouchCenter(e);
                curX = center.x; curY = center.y;
            } else {
                curX = e.clientX; curY = e.clientY;
            }

            // Only mark as moved if shifted significantly (avoids micro-jitters)
            if (!isTwoFinger && (Math.abs(curX - startX) > 10 || Math.abs(curY - startY) > 10)) {
                hasMoved = true;
            }
            if (isTwoFinger && (Math.abs(curX - lastPanX) > 2 || Math.abs(curY - lastPanY) > 2)) {
                hasMoved = true;
            }

            // --- TOUCH MOVE ---
            if (e.type === 'touchmove') {
                e.preventDefault(); // Stop Scroll
                if (isTwoFinger) {
                    // 2 Finger Pan
                    const center = getTouchCenter(e);
                    const dx = center.x - lastPanX;
                    const dy = center.y - lastPanY;
                    camera.x -= dx; camera.y -= dy; // Move map opposite to finger
                    camera.velX = -dx; camera.velY = -dy;
                    lastPanX = center.x; lastPanY = center.y;
                } else {
                    // 1 Finger Box Select
                    if (hasMoved) {
                        const rect = canvas.getBoundingClientRect();
                        const clientX = e.touches[0].clientX - rect.left;
                        const clientY = e.touches[0].clientY - rect.top;
                        const startRelX = startX - rect.left;
                        const startRelY = startY - rect.top;

                        const w = clientX - startRelX;
                        const h = clientY - startRelY;
                        selectionBox.style.width = Math.abs(w) + 'px';
                        selectionBox.style.height = Math.abs(h) + 'px';
                        selectionBox.style.left = (w < 0 ? clientX + rect.left : startX) + 'px';
                        selectionBox.style.top = (h < 0 ? clientY + rect.top : startY) + 'px';
                    }
                }
            }
            // --- MOUSE MOVE ---
            else {
                if (isRightClick) {
                    // Right Drag = Box Select
                    if (hasMoved) {
                        const rect = canvas.getBoundingClientRect();
                        const clientX = e.clientX - rect.left;
                        const clientY = e.clientY - rect.top;
                        const startRelX = startX - rect.left;
                        const startRelY = startY - rect.top;

                        const w = clientX - startRelX;
                        const h = clientY - startRelY;
                        selectionBox.style.width = Math.abs(w) + 'px';
                        selectionBox.style.height = Math.abs(h) + 'px';
                        selectionBox.style.left = (w < 0 ? clientX + rect.left : startX) + 'px';
                        selectionBox.style.top = (h < 0 ? clientY + rect.top : startY) + 'px';
                    }
                } else {
                    // Left Drag = Pan
                    const dx = e.clientX - lastPanX;
                    const dy = e.clientY - lastPanY;
                    camera.x -= dx; camera.y -= dy;
                    camera.velX = -dx; camera.velY = -dy;
                    lastPanX = e.clientX; lastPanY = e.clientY;
                }
            }
        }

        function handleEnd(e) {
            if (!pointerDown) return;
            pointerDown = false;
            selectionBox.style.display = 'none';

            const rect = canvas.getBoundingClientRect();

            // --- CLICK / TAP (No Movement) ---
            if (!hasMoved && !isTwoFinger) {
                let clientX, clientY;
                if (e.type === 'touchend') {
                    // Use start coords because changedTouches might be empty or confusing
                    clientX = startX; clientY = startY;
                } else {
                    clientX = e.clientX; clientY = e.clientY;
                }

                const worldX = (clientX - rect.left) + camera.x;
                const worldY = (clientY - rect.top) + camera.y;

                if (isRightClick) {
                    // Desktop Right Click = Move Command
                    issueMoveCommand(worldX, worldY);
                } else {
                    // Desktop Left Click OR Touch Tap
                    // Logic: If tapped on Unit -> Select. If tapped on Ground -> Move (if units selected).
                    let clickedUnit = false;
                    world.units.forEach(u => {
                        if (dist(u.x, u.y, worldX, worldY) < u.radius + 15) clickedUnit = true;
                    });

                    const hasSelection = world.units.some(u => u.selected);

                    if (clickedUnit) {
                        // Select Logic
                        world.units.forEach(u => u.selected = false);
                        world.units.forEach(u => {
                            if (dist(u.x, u.y, worldX, worldY) < u.radius + 15) u.selected = true;
                        });
                    } else {
                        if (hasSelection && e.type === 'touchend') {
                            // Touch: Tap on empty ground with selection = Move
                            issueMoveCommand(worldX, worldY);
                        } else {
                            // Deselect All
                            world.units.forEach(u => u.selected = false);
                        }
                    }
                }
            }
            // --- DRAG END (Selection Box Finalize) ---
            else if (hasMoved) {
                // If it was Right Drag (Mouse) or 1-Finger Drag (Touch) -> Select Units in Box
                if ((isRightClick) || (e.type === 'touchend' && !isTwoFinger)) {
                    // Get end coordinates. For touch, use last known position?
                    // changedTouches[0] usually available
                    let endX, endY;
                    if (e.type === 'touchend') {
                        if (e.changedTouches.length > 0) {
                            endX = e.changedTouches[0].clientX;
                            endY = e.changedTouches[0].clientY;
                        } else { endX = startX; endY = startY; }
                    } else {
                        endX = e.clientX; endY = e.clientY;
                    }

                    const wx1 = (startX - rect.left) + camera.x; const wy1 = (startY - rect.top) + camera.y;
                    const wx2 = (endX - rect.left) + camera.x; const wy2 = (endY - rect.top) + camera.y;

                    const x1 = Math.min(wx1, wx2); const y1 = Math.min(wy1, wy2);
                    const x2 = Math.max(wx1, wx2); const y2 = Math.max(wy1, wy2);

                    world.units.forEach(u => u.selected = false);
                    world.units.forEach(u => {
                        if (u.x > x1 && u.x < x2 && u.y > y1 && u.y < y2) u.selected = true;
                    });
                }
            }

            isRightClick = false;
            isTwoFinger = false;
        }

        function issueMoveCommand(wx, wy) {
            world.particles.push(new MoveMarker(wx, wy));
            world.units.forEach(u => {
                if (u.selected) {
                    const path = world.grid.findPath(u.x, u.y, wx, wy);
                    u.setPath(path, wx, wy);
                }
            });
        }

        // Listeners
        canvas.addEventListener('mousedown', handleStart);
        window.addEventListener('mousemove', handleMove);
        window.addEventListener('mouseup', handleEnd);

        canvas.addEventListener('touchstart', handleStart, { passive: false });
        window.addEventListener('touchmove', handleMove, { passive: false });
        window.addEventListener('touchend', handleEnd);

        // Desktop Context Menu (Disable default right click menu)
        window.addEventListener('contextmenu', e => e.preventDefault());

        // Radar navigation
        radar.addEventListener('mousedown', e => {
            const rect = radar.getBoundingClientRect();
            const cx = e.clientX - rect.left;
            const cy = e.clientY - rect.top;
            camera.x = ((cx / 250) * WORLD_W) - canvas.width / 2;
            camera.y = ((cy / 200) * WORLD_H) - canvas.height / 2;
            camera.velX = 0; camera.velY = 0; camera.target = null;
        });

        window.addEventListener('keydown', e => {
            if (e.code === 'Space') {
                const selected = world.units.find(u => u.selected);
                camera.target = selected ? selected : null;
            }
        });

        let tick = 0;
        function loop() {
            camera.update();
            world.update();
            ctx.fillStyle = '#2b3a42'; ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.save(); ctx.translate(-camera.x, -camera.y);
            world.draw();
            ctx.restore();
            if (tick++ % 10 === 0) world.updateRadar();
            requestAnimationFrame(loop);
        }

        world.trySpawn('tank'); world.trySpawn('tank'); world.trySpawn('soldier');
        loop();

    </script>
</body>

</html>