<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Red Alert Clone V6 (World & Camera)</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            font-family: 'Courier New', Courier, monospace;
        }

        #game-container {
            display: flex;
            height: 100vh;
        }

        #canvas-container {
            flex-grow: 1;
            position: relative;
            cursor: crosshair;
            overflow: hidden;
        }

        canvas {
            display: block;
            background-color: #2b3a42;
        }

        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 10px;
            left: 10px;
            pointer-events: none;
            color: white;
            text-shadow: 1px 1px 0 #000;
        }

        #sidebar {
            width: 250px;
            background: #1a1a1a;
            border-left: 4px solid #4a4a4a;
            z-index: 10;
            display: flex;
            flex-direction: column;
            padding: 10px;
            color: #00ff00;
            user-select: none;
        }

        .title {
            text-align: center;
            font-weight: bold;
            border-bottom: 2px solid #555;
            margin-bottom: 20px;
            padding-bottom: 10px;
        }

        .radar {
            width: 100%;
            height: 200px;
            background: #000;
            border: 2px solid #005500;
            margin-bottom: 20px;
            position: relative;
            overflow: hidden;
        }

        /* Radar Dot */
        .radar-dot {
            position: absolute;
            width: 2px;
            height: 2px;
            background: #0f0;
        }

        .build-btn {
            background: #333;
            border: 2px solid #555;
            color: #ddd;
            padding: 15px;
            margin-bottom: 10px;
            cursor: pointer;
            text-align: center;
            font-weight: bold;
            transition: 0.2s;
        }

        .build-btn:hover {
            background: #555;
            border-color: #ddd;
        }

        .build-btn:active {
            background: #222;
        }

        #selection-box {
            position: absolute;
            border: 1px solid #00ff00;
            background-color: rgba(0, 255, 0, 0.2);
            display: none;
            pointer-events: none;
        }
    </style>
</head>

<body>

    <div id="game-container">
        <div id="canvas-container">
            <canvas id="gameCanvas"></canvas>
            <div id="selection-box"></div>
            <div id="ui-layer">
                <h2 style="margin:0">SECTOR 7G</h2>
                <small>Press SPACE to toggle Camera Follow</small>
            </div>
        </div>
        <div id="sidebar">
            <div class="title">RED ALERT v6<br><span style="font-size:10px; color:yellow">WORLD ENGINE</span></div>
            <div class="radar" id="radar"></div>
            <div class="build-btn" onclick="world.trySpawn('tank')">BUILD TANK ($800)</div>
            <div class="build-btn" onclick="world.trySpawn('soldier')">BUILD RIFLE ($100)</div>
            <div style="font-size: 11px; color: #888; margin-top: auto;">
                Mouse Edge: Pan Map<br>Spacebar: Follow Unit
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const selectionBox = document.getElementById('selection-box');
        const radar = document.getElementById('radar');

        // --- Configuration ---
        const WORLD_W = 3000;
        const WORLD_H = 3000;

        function resize() {
            canvas.width = document.getElementById('canvas-container').offsetWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        // --- Math Utils ---
        const normalizeAngle = a => { while (a > Math.PI) a -= Math.PI * 2; while (a < -Math.PI) a += Math.PI * 2; return a; };
        const dist = (x1, y1, x2, y2) => Math.hypot(x2 - x1, y2 - y1);
        const clamp = (val, min, max) => Math.min(Math.max(val, min), max);

        // --- Camera Class ---
        class Camera {
            constructor() {
                this.x = 1000; // Start in middle of world
                this.y = 1000;
                this.velX = 0;
                this.velY = 0;
                this.target = null; // Object to follow

                // Physics
                this.friction = 0.9;
                this.acceleration = 2.0;
                this.maxSpeed = 20;
            }

            update() {
                // 1. Follow Logic (Spring system)
                if (this.target) {
                    // Desired position (Centered on target)
                    const tx = this.target.x - canvas.width / 2;
                    const ty = this.target.y - canvas.height / 2;

                    // Spring force
                    const forceX = (tx - this.x) * 0.05; // 0.05 is "spring tension"
                    const forceY = (ty - this.y) * 0.05;

                    this.velX += forceX;
                    this.velY += forceY;

                    // Heavier damping when following so it doesn't wobble
                    this.velX *= 0.8;
                    this.velY *= 0.8;
                }
                // 2. Manual Panning Logic (Mouse Edges)
                else {
                    let panX = 0;
                    let panY = 0;
                    const margin = 50; // pixels from edge

                    if (mouseScreenX < margin) panX = -1;
                    if (mouseScreenX > canvas.width - margin) panX = 1;
                    if (mouseScreenY < margin) panY = -1;
                    if (mouseScreenY > canvas.height - margin) panY = 1;

                    // Apply acceleration
                    if (panX !== 0) this.velX += panX * this.acceleration;
                    if (panY !== 0) this.velY += panY * this.acceleration;

                    // Apply Friction
                    this.velX *= this.friction;
                    this.velY *= this.friction;
                }

                // Apply Velocity
                this.x += this.velX;
                this.y += this.velY;

                // Clamp to World Bounds
                if (this.x < 0) { this.x = 0; this.velX = 0; }
                if (this.y < 0) { this.y = 0; this.velY = 0; }
                if (this.x > WORLD_W - canvas.width) { this.x = WORLD_W - canvas.width; this.velX = 0; }
                if (this.y > WORLD_H - canvas.height) { this.y = WORLD_H - canvas.height; this.velY = 0; }
            }
        }

        // --- Static Objects (Terrain) ---
        class Obstacle {
            constructor(x, y, r, type) {
                this.x = x; this.y = y; this.radius = r; this.type = type;

                // Pre-render aesthetic details based on type
                if (type === 'rock') {
                    this.points = [];
                    const sides = 5 + Math.random() * 3;
                    for (let i = 0; i < sides; i++) {
                        const angle = (i / sides) * Math.PI * 2;
                        const rad = r * (0.8 + Math.random() * 0.4);
                        this.points.push({ x: Math.cos(angle) * rad, y: Math.sin(angle) * rad });
                    }
                }
            }
            draw() {
                ctx.translate(this.x, this.y);
                if (this.type === 'tree') {
                    ctx.fillStyle = '#1a331a'; // Dark Shadow
                    ctx.beginPath(); ctx.arc(3, 3, this.radius, 0, Math.PI * 2); ctx.fill();
                    ctx.fillStyle = '#2d5a2d'; // Tree
                    ctx.beginPath(); ctx.arc(0, 0, this.radius, 0, Math.PI * 2); ctx.fill();
                    ctx.fillStyle = '#3e7a3e'; // Highlight
                    ctx.beginPath(); ctx.arc(-this.radius * 0.3, -this.radius * 0.3, this.radius * 0.4, 0, Math.PI * 2); ctx.fill();
                } else if (this.type === 'rock') {
                    ctx.fillStyle = '#555';
                    ctx.beginPath();
                    ctx.moveTo(this.points[0].x, this.points[0].y);
                    this.points.forEach(p => ctx.lineTo(p.x, p.y));
                    ctx.fill();
                    // Texture
                    ctx.strokeStyle = '#666'; ctx.lineWidth = 2; ctx.stroke();
                } else if (this.type === 'building') {
                    ctx.fillStyle = '#111';
                    ctx.fillRect(-this.radius, -this.radius, this.radius * 2, this.radius * 2);
                    ctx.fillStyle = '#444';
                    ctx.fillRect(-this.radius + 2, -this.radius + 2, this.radius * 2 - 4, this.radius * 2 - 4);
                    // Roof
                    ctx.fillStyle = '#222';
                    ctx.fillRect(-this.radius + 10, -this.radius + 10, this.radius * 2 - 20, this.radius * 2 - 20);
                }
                ctx.translate(-this.x, -this.y);
            }
        }

        // --- Unit Class (From V5 with updates) ---
        class Unit {
            constructor(x, y, type) {
                this.x = x; this.y = y; this.type = type; this.selected = false;
                this.targetX = x; this.targetY = y;
                this.angle = Math.random() * Math.PI * 2;
                this.currentSpeed = 0;
                this.isBraking = false;

                if (type === 'tank') {
                    this.color = '#ccaa00'; this.radius = 28;
                    this.maxSpeed = 3.0; this.acceleration = 0.08; this.brakingForce = 0.15;
                    this.friction = 0.98; this.turnSpeed = 0.04; this.health = 100;
                } else {
                    this.color = '#aaaaaa'; this.radius = 10;
                    this.maxSpeed = 1.8; this.acceleration = 0.2; this.brakingForce = 0.3;
                    this.friction = 0.85; this.turnSpeed = 0.3; this.health = 30;
                }
            }
            update() {
                const d = dist(this.x, this.y, this.targetX, this.targetY);
                const targetAngle = Math.atan2(this.targetY - this.y, this.targetX - this.x);
                let diff = normalizeAngle(targetAngle - this.angle);

                if (Math.abs(diff) > this.turnSpeed && d > 5) this.angle += Math.sign(diff) * this.turnSpeed;
                else if (d > 5) this.angle = targetAngle;

                this.isBraking = false;
                let throttle = 0;
                const stoppingDist = (this.currentSpeed * this.currentSpeed) / (2 * this.brakingForce);

                if (d < 5 || d < stoppingDist + 20 || (d > 20 && Math.abs(diff) > Math.PI / 4)) this.isBraking = true;
                else throttle = 1;

                if (this.isBraking) {
                    if (this.currentSpeed > 0) this.currentSpeed -= this.brakingForce;
                    if (this.currentSpeed < 0) this.currentSpeed = 0;
                } else if (this.currentSpeed < this.maxSpeed) {
                    this.currentSpeed += this.acceleration * throttle;
                }

                this.currentSpeed *= this.friction;
                this.x += Math.cos(this.angle) * this.currentSpeed;
                this.y += Math.sin(this.angle) * this.currentSpeed;

                // World Bounds
                this.x = clamp(this.x, this.radius, WORLD_W - this.radius);
                this.y = clamp(this.y, this.radius, WORLD_H - this.radius);

                if (this.currentSpeed > 0.5 && this.type === 'tank' && !this.isBraking && Math.random() > 0.8) {
                    world.particles.push(new Dust(this.x - Math.cos(this.angle) * 15, this.y - Math.sin(this.angle) * 15));
                }
            }
            draw() {
                // Frustum Culling (Don't draw if off screen)
                if (this.x < camera.x - 50 || this.x > camera.x + canvas.width + 50 ||
                    this.y < camera.y - 50 || this.y > camera.y + canvas.height + 50) return;

                ctx.translate(this.x, this.y);
                if (this.selected) {
                    ctx.strokeStyle = '#00ff00'; ctx.lineWidth = 1; ctx.beginPath();
                    ctx.arc(0, 0, this.radius + 2, 0, Math.PI * 2); ctx.stroke();
                    ctx.fillStyle = '#00ff00'; ctx.fillRect(-12, -this.radius - 8, 24 * (this.health / 100), 3);
                }
                ctx.rotate(this.angle);
                if (this.type === 'tank') {
                    ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.fillRect(-15, -10, 36, 28);
                    ctx.fillStyle = this.color; ctx.fillRect(-18, -14, 36, 28);
                    if (this.isBraking) {
                        ctx.fillStyle = '#ff0000'; ctx.shadowColor = '#ff0000'; ctx.shadowBlur = 10;
                        ctx.fillRect(-18, -12, 2, 6); ctx.fillRect(-18, 6, 2, 6); ctx.shadowBlur = 0;
                    }
                    ctx.fillStyle = '#080808'; ctx.fillRect(-18, -16, 36, 4); ctx.fillRect(-18, 12, 36, 4);
                    ctx.fillStyle = '#333';
                    for (let i = -16; i < 16; i += 4) { ctx.fillRect(i, -16, 1, 4); ctx.fillRect(i, 12, 1, 4); }
                    ctx.fillStyle = '#997700'; ctx.beginPath(); ctx.arc(-2, 0, 11, 0, Math.PI * 2); ctx.fill();
                    ctx.strokeStyle = '#886600'; ctx.lineWidth = 6; ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(26, 0); ctx.stroke();
                } else {
                    ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(0, 0, 6, 0, Math.PI * 2); ctx.fill();
                    ctx.fillStyle = '#222'; ctx.fillRect(0, -2, 10, 4);
                }
                ctx.rotate(-this.angle);
                ctx.translate(-this.x, -this.y);
            }
            setDestination(x, y) {
                const spread = 40;
                this.targetX = x + (Math.random() * spread - spread / 2);
                this.targetY = y + (Math.random() * spread - spread / 2);
            }
        }

        class Dust {
            constructor(x, y) { this.x = x; this.y = y; this.size = Math.random() * 5 + 2; this.life = 1.0; }
            update() { this.life -= 0.05; this.size += 0.2; }
            draw() {
                ctx.fillStyle = `rgba(150, 140, 100, ${this.life * 0.3})`;
                ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill();
            }
        }
        class MoveMarker {
            constructor(x, y) { this.x = x; this.y = y; this.life = 20; }
            update() { this.life--; }
            draw() {
                ctx.strokeStyle = '#00ff00'; ctx.lineWidth = 2; ctx.beginPath();
                ctx.moveTo(this.x - 5, this.y - 5); ctx.lineTo(this.x + 5, this.y + 5);
                ctx.moveTo(this.x + 5, this.y - 5); ctx.lineTo(this.x - 5, this.y + 5); ctx.stroke();
            }
        }

        // --- World Engine ---
        class World {
            constructor() {
                this.units = [];
                this.obstacles = [];
                this.particles = [];
                this.generateMap();
            }

            generateMap() {
                // 1. Create Forests
                for (let i = 0; i < 40; i++) {
                    const cx = Math.random() * WORLD_W;
                    const cy = Math.random() * WORLD_H;
                    // Cluster of trees
                    for (let j = 0; j < 10; j++) {
                        const tx = cx + Math.random() * 200 - 100;
                        const ty = cy + Math.random() * 200 - 100;
                        this.obstacles.push(new Obstacle(tx, ty, 15 + Math.random() * 15, 'tree'));
                    }
                }
                // 2. Create Rocks
                for (let i = 0; i < 30; i++) {
                    this.obstacles.push(new Obstacle(Math.random() * WORLD_W, Math.random() * WORLD_H, 30 + Math.random() * 30, 'rock'));
                }
                // 3. Create Buildings
                for (let i = 0; i < 15; i++) {
                    this.obstacles.push(new Obstacle(Math.random() * WORLD_W, Math.random() * WORLD_H, 60 + Math.random() * 20, 'building'));
                }
                // Clear spawn area
                this.obstacles = this.obstacles.filter(o => dist(o.x, o.y, 1000, 1000) > 300);
            }

            resolveCollisions() {
                // Unit vs Unit
                for (let i = 0; i < this.units.length; i++) {
                    for (let j = i + 1; j < this.units.length; j++) {
                        const u1 = this.units[i]; const u2 = this.units[j];
                        const d = dist(u1.x, u1.y, u2.x, u2.y);
                        const minD = u1.radius + u2.radius;
                        if (d < minD) {
                            const overlap = minD - d;
                            const angle = Math.atan2(u1.y - u2.y, u1.x - u2.x);
                            const force = overlap * 0.1;
                            const px = Math.cos(angle) * force; const py = Math.sin(angle) * force;
                            u1.x += px; u1.y += py; u2.x -= px; u2.y -= py;
                            u1.currentSpeed *= 0.95; u2.currentSpeed *= 0.95;
                        }
                    }
                }
                // Unit vs Obstacle
                for (let u of this.units) {
                    for (let o of this.obstacles) {
                        const d = dist(u.x, u.y, o.x, o.y);
                        const minD = u.radius + o.radius; // Circle collision approximation
                        if (d < minD) {
                            const overlap = minD - d;
                            const angle = Math.atan2(u.y - o.y, u.x - o.x);
                            // Static obstacle implies Infinite mass, so unit moves 100% of overlap
                            u.x += Math.cos(angle) * overlap;
                            u.y += Math.sin(angle) * overlap;
                            u.currentSpeed *= 0.8; // Hitting rock slows you down hard
                        }
                    }
                }
            }

            trySpawn(type) {
                const rx = camera.x + canvas.width / 2 + (Math.random() * 200 - 100);
                const ry = camera.y + canvas.height / 2 + (Math.random() * 200 - 100);
                this.units.push(new Unit(rx, ry, type));
            }

            update() {
                this.units.forEach(u => u.update());
                this.resolveCollisions();
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    this.particles[i].update();
                    if (this.particles[i].life <= 0) this.particles.splice(i, 1);
                }
            }

            draw() {
                // Draw Grid
                ctx.strokeStyle = '#35454d'; ctx.lineWidth = 1; ctx.beginPath();
                const startX = Math.floor(camera.x / 100) * 100;
                const startY = Math.floor(camera.y / 100) * 100;
                for (let x = startX; x < camera.x + canvas.width; x += 100) { ctx.moveTo(x, camera.y); ctx.lineTo(x, camera.y + canvas.height); }
                for (let y = startY; y < camera.y + canvas.height; y += 100) { ctx.moveTo(camera.x, y); ctx.lineTo(camera.x + canvas.width, y); }
                ctx.stroke();

                // Draw Bounds
                ctx.strokeStyle = '#ff0000'; ctx.lineWidth = 5; ctx.strokeRect(0, 0, WORLD_W, WORLD_H);

                this.obstacles.forEach(o => {
                    // Simple Culling
                    if (o.x > camera.x - 100 && o.x < camera.x + canvas.width + 100 &&
                        o.y > camera.y - 100 && o.y < camera.y + canvas.height + 100) o.draw();
                });
                this.particles.forEach(p => p.draw());
                this.units.forEach(u => u.draw());
            }

            updateRadar() {
                // Mini-map logic
                radar.innerHTML = '';
                // Scale factor
                const sx = 250 / WORLD_W;
                const sy = 200 / WORLD_H;

                // Draw Viewport Rect on radar
                const vDiv = document.createElement('div');
                vDiv.style.position = 'absolute';
                vDiv.style.border = '1px solid white';
                vDiv.style.left = (camera.x * sx) + 'px';
                vDiv.style.top = (camera.y * sy) + 'px';
                vDiv.style.width = (canvas.width * sx) + 'px';
                vDiv.style.height = (canvas.height * sy) + 'px';
                radar.appendChild(vDiv);

                // Draw Units on radar (optimized: just dots)
                this.units.forEach(u => {
                    const d = document.createElement('div');
                    d.className = 'radar-dot';
                    if (u.type === 'tank') d.style.background = 'gold';
                    d.style.left = (u.x * sx) + 'px';
                    d.style.top = (u.y * sy) + 'px';
                    radar.appendChild(d);
                });
            }
        }

        // --- Input Handling ---
        const world = new World();
        const camera = new Camera();

        let mouseScreenX = 0, mouseScreenY = 0;
        let isDragging = false;
        let startWorldX, startWorldY;

        // Track mouse for Edge Panning
        window.addEventListener('mousemove', e => {
            const rect = canvas.getBoundingClientRect();
            mouseScreenX = e.clientX - rect.left;
            mouseScreenY = e.clientY - rect.top;

            if (isDragging) {
                const worldX = mouseScreenX + camera.x;
                const worldY = mouseScreenY + camera.y;

                const w = worldX - startWorldX;
                const h = worldY - startWorldY;

                // Draw Box in Screen Coords for CSS
                selectionBox.style.width = Math.abs(w) + 'px';
                selectionBox.style.height = Math.abs(h) + 'px';
                selectionBox.style.left = (w < 0 ? mouseScreenX : mouseScreenX - w) + 'px';
                selectionBox.style.top = (h < 0 ? mouseScreenY : mouseScreenY - h) + 'px';
            }
        });

        canvas.addEventListener('mousedown', e => {
            if (e.button !== 0) return;
            isDragging = true;
            // Break follow mode if manual interaction happens
            camera.target = null;

            startWorldX = mouseScreenX + camera.x;
            startWorldY = mouseScreenY + camera.y;

            selectionBox.style.display = 'block';
            selectionBox.style.left = mouseScreenX + 'px';
            selectionBox.style.top = mouseScreenY + 'px';
            selectionBox.style.width = '0'; selectionBox.style.height = '0';
        });

        canvas.addEventListener('mouseup', e => {
            if (e.button !== 0) return;
            isDragging = false;
            selectionBox.style.display = 'none';

            const endWorldX = mouseScreenX + camera.x;
            const endWorldY = mouseScreenY + camera.y;

            const x1 = Math.min(startWorldX, endWorldX); const y1 = Math.min(startWorldY, endWorldY);
            const x2 = Math.max(startWorldX, endWorldX); const y2 = Math.max(startWorldY, endWorldY);

            world.units.forEach(u => u.selected = false);

            if (Math.abs(x2 - x1) > 5 || Math.abs(y2 - y1) > 5) {
                world.units.forEach(u => {
                    if (u.x > x1 && u.x < x2 && u.y > y1 && u.y < y2) u.selected = true;
                });
            } else {
                world.units.forEach(u => {
                    if (dist(u.x, u.y, endWorldX, endWorldY) < u.radius + 5) u.selected = true;
                });
            }
        });

        window.addEventListener('contextmenu', e => {
            e.preventDefault();
            const worldX = mouseScreenX + camera.x;
            const worldY = mouseScreenY + camera.y;
            world.particles.push(new MoveMarker(worldX, worldY));
            world.units.forEach(u => { if (u.selected) u.setDestination(worldX, worldY); });
        });

        window.addEventListener('keydown', e => {
            if (e.code === 'Space') {
                const selected = world.units.find(u => u.selected);
                if (selected) {
                    camera.target = selected; // Lock camera
                } else {
                    camera.target = null; // Unlock
                }
            }
        });

        // --- Main Loop ---
        let tick = 0;
        function loop() {
            // Update Physics
            camera.update();
            world.update();

            // Render
            ctx.fillStyle = '#2b3a42';
            ctx.fillRect(0, 0, canvas.width, canvas.height); // Clear Screen

            ctx.save();
            // Shift the entire world by negative camera position
            ctx.translate(-camera.x, -camera.y);

            world.draw();

            ctx.restore();

            // Radar update (expensive, do every 10 frames)
            if (tick++ % 10 === 0) world.updateRadar();

            requestAnimationFrame(loop);
        }

        // Start
        world.trySpawn('tank'); world.trySpawn('tank'); world.trySpawn('soldier');
        loop();

    </script>
</body>

</html>