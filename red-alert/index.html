<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Red Alert Clone V7 (A* Pathfinding)</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            font-family: 'Courier New', Courier, monospace;
        }

        #game-container {
            display: flex;
            height: 100vh;
        }

        #canvas-container {
            flex-grow: 1;
            position: relative;
            cursor: crosshair;
            overflow: hidden;
        }

        canvas {
            display: block;
            background-color: #2b3a42;
        }

        #ui-layer {
            position: absolute;
            top: 10px;
            left: 10px;
            pointer-events: none;
            color: white;
            text-shadow: 1px 1px 0 #000;
        }

        #sidebar {
            width: 250px;
            background: #1a1a1a;
            border-left: 4px solid #4a4a4a;
            z-index: 10;
            display: flex;
            flex-direction: column;
            padding: 10px;
            color: #00ff00;
            user-select: none;
        }

        .title {
            text-align: center;
            font-weight: bold;
            border-bottom: 2px solid #555;
            margin-bottom: 20px;
            padding-bottom: 10px;
        }

        .radar {
            width: 100%;
            height: 200px;
            background: #000;
            border: 2px solid #005500;
            margin-bottom: 20px;
            position: relative;
            overflow: hidden;
        }

        .radar-dot {
            position: absolute;
            width: 2px;
            height: 2px;
            background: #0f0;
        }

        .build-btn {
            background: #333;
            border: 2px solid #555;
            color: #ddd;
            padding: 15px;
            margin-bottom: 10px;
            cursor: pointer;
            text-align: center;
            font-weight: bold;
            transition: 0.2s;
        }

        .build-btn:hover {
            background: #555;
            border-color: #ddd;
        }

        .build-btn:active {
            background: #222;
        }

        #selection-box {
            position: absolute;
            border: 1px solid #00ff00;
            background-color: rgba(0, 255, 0, 0.2);
            display: none;
            pointer-events: none;
        }
    </style>
</head>

<body>

    <div id="game-container">
        <div id="canvas-container">
            <canvas id="gameCanvas"></canvas>
            <div id="selection-box"></div>
            <div id="ui-layer">
                <h2 style="margin:0">SECTOR 7G</h2>
                <small>Units now navigate AROUND obstacles.</small>
            </div>
        </div>
        <div id="sidebar">
            <div class="title">RED ALERT v7<br><span style="font-size:10px; color:orange">A* PATHFINDING</span></div>
            <div class="radar" id="radar"></div>
            <div class="build-btn" onclick="world.trySpawn('tank')">BUILD TANK ($800)</div>
            <div class="build-btn" onclick="world.trySpawn('soldier')">BUILD RIFLE ($100)</div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const selectionBox = document.getElementById('selection-box');
        const radar = document.getElementById('radar');

        const WORLD_W = 3000;
        const WORLD_H = 3000;
        const GRID_SIZE = 50; // Size of pathfinding cells

        function resize() {
            canvas.width = document.getElementById('canvas-container').offsetWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        // --- Math Utils ---
        const normalizeAngle = a => { while (a > Math.PI) a -= Math.PI * 2; while (a < -Math.PI) a += Math.PI * 2; return a; };
        const dist = (x1, y1, x2, y2) => Math.hypot(x2 - x1, y2 - y1);
        const clamp = (val, min, max) => Math.min(Math.max(val, min), max);

        // --- A* Pathfinding Logic ---

        class Grid {
            constructor(width, height, cellSize) {
                this.cellSize = cellSize;
                this.cols = Math.ceil(width / cellSize);
                this.rows = Math.ceil(height / cellSize);
                this.grid = []; // 0 = Walkable, 1 = Blocked

                // Init Grid
                for (let y = 0; y < this.rows; y++) {
                    this.grid[y] = [];
                    for (let x = 0; x < this.cols; x++) {
                        this.grid[y][x] = 0;
                    }
                }
            }

            markObstacle(x, y, radius) {
                // Determine grid bounds for this obstacle
                const startCol = Math.floor((x - radius) / this.cellSize);
                const endCol = Math.floor((x + radius) / this.cellSize);
                const startRow = Math.floor((y - radius) / this.cellSize);
                const endRow = Math.floor((y + radius) / this.cellSize);

                for (let r = startRow; r <= endRow; r++) {
                    for (let c = startCol; c <= endCol; c++) {
                        if (r >= 0 && r < this.rows && c >= 0 && c < this.cols) {
                            this.grid[r][c] = 1; // Mark blocked
                        }
                    }
                }
            }

            // The A* Algorithm
            findPath(startX, startY, endX, endY) {
                const startNode = { x: Math.floor(startX / this.cellSize), y: Math.floor(startY / this.cellSize) };
                const endNode = { x: Math.floor(endX / this.cellSize), y: Math.floor(endY / this.cellSize) };

                // Clamp to grid
                if (startNode.x < 0 || startNode.x >= this.cols || startNode.y < 0 || startNode.y >= this.rows) return [];
                if (endNode.x < 0 || endNode.x >= this.cols || endNode.y < 0 || endNode.y >= this.rows) return [];

                // If target is blocked, find nearest open neighbor (simple adjustment)
                if (this.grid[endNode.y][endNode.x] === 1) return [];

                const openSet = [];
                const closedSet = new Set();

                // Initial Node
                openSet.push({ ...startNode, g: 0, h: 0, f: 0, parent: null });

                while (openSet.length > 0) {
                    // Find node with lowest F score
                    let lowestIndex = 0;
                    for (let i = 1; i < openSet.length; i++) {
                        if (openSet[i].f < openSet[lowestIndex].f) lowestIndex = i;
                    }

                    let current = openSet[lowestIndex];

                    // Check if reached end
                    if (current.x === endNode.x && current.y === endNode.y) {
                        let path = [];
                        let temp = current;
                        while (temp.parent) {
                            // Convert grid coords back to world coords (center of cell)
                            path.push({
                                x: temp.x * this.cellSize + this.cellSize / 2,
                                y: temp.y * this.cellSize + this.cellSize / 2
                            });
                            temp = temp.parent;
                        }
                        return path.reverse();
                    }

                    // Move current from Open to Closed
                    openSet.splice(lowestIndex, 1);
                    closedSet.add(`${current.x},${current.y}`);

                    // Neighbors (Up, Down, Left, Right, Diagonals)
                    const neighbors = [
                        { x: 0, y: -1 }, { x: 0, y: 1 }, { x: -1, y: 0 }, { x: 1, y: 0 },
                        { x: -1, y: -1 }, { x: 1, y: -1 }, { x: -1, y: 1 }, { x: 1, y: 1 }
                    ];

                    for (let neighbor of neighbors) {
                        const nx = current.x + neighbor.x;
                        const ny = current.y + neighbor.y;

                        // Bounds check & Blocked check
                        if (nx < 0 || ny < 0 || nx >= this.cols || ny >= this.rows) continue;
                        if (this.grid[ny][nx] === 1) continue;
                        if (closedSet.has(`${nx},${ny}`)) continue;

                        // Calculate G cost (distance from start)
                        // Diagonals cost 1.4, straights 1.0
                        const distCost = (Math.abs(neighbor.x) + Math.abs(neighbor.y) === 2) ? 1.4 : 1.0;
                        const tempG = current.g + distCost;

                        let neighborNode = openSet.find(n => n.x === nx && n.y === ny);
                        if (!neighborNode) {
                            neighborNode = { x: nx, y: ny, g: tempG, h: 0, f: 0, parent: current };
                            // H heuristic: Manhattan distance
                            neighborNode.h = Math.abs(nx - endNode.x) + Math.abs(ny - endNode.y);
                            neighborNode.f = neighborNode.g + neighborNode.h;
                            openSet.push(neighborNode);
                        } else if (tempG < neighborNode.g) {
                            neighborNode.g = tempG;
                            neighborNode.f = neighborNode.g + neighborNode.h;
                            neighborNode.parent = current;
                        }
                    }
                }
                return []; // No path found
            }
        }

        // --- Camera & Objects ---

        class Camera {
            constructor() {
                this.x = 1000; this.y = 1000; this.velX = 0; this.velY = 0;
                this.target = null; this.friction = 0.9; this.acceleration = 2.0;
            }
            update() {
                if (this.target) {
                    const tx = this.target.x - canvas.width / 2;
                    const ty = this.target.y - canvas.height / 2;
                    this.velX += (tx - this.x) * 0.05; this.velY += (ty - this.y) * 0.05;
                    this.velX *= 0.8; this.velY *= 0.8;
                } else {
                    let px = 0, py = 0, margin = 50;
                    if (mouseScreenX < margin) px = -1; if (mouseScreenX > canvas.width - margin) px = 1;
                    if (mouseScreenY < margin) py = -1; if (mouseScreenY > canvas.height - margin) py = 1;
                    if (px !== 0) this.velX += px * this.acceleration; if (py !== 0) this.velY += py * this.acceleration;
                    this.velX *= this.friction; this.velY *= this.friction;
                }
                this.x += this.velX; this.y += this.velY;
                if (this.x < 0) this.x = 0; if (this.y < 0) this.y = 0;
                if (this.x > WORLD_W - canvas.width) this.x = WORLD_W - canvas.width;
                if (this.y > WORLD_H - canvas.height) this.y = WORLD_H - canvas.height;
            }
        }

        class Obstacle {
            constructor(x, y, r, type) {
                this.x = x; this.y = y; this.radius = r; this.type = type;
                if (type === 'rock') {
                    this.points = []; const sides = 5 + Math.random() * 3;
                    for (let i = 0; i < sides; i++) {
                        const angle = (i / sides) * Math.PI * 2; const rad = r * (0.8 + Math.random() * 0.4);
                        this.points.push({ x: Math.cos(angle) * rad, y: Math.sin(angle) * rad });
                    }
                }
            }
            draw() {
                ctx.translate(this.x, this.y);
                if (this.type === 'tree') {
                    ctx.fillStyle = '#1a331a'; ctx.beginPath(); ctx.arc(3, 3, this.radius, 0, Math.PI * 2); ctx.fill();
                    ctx.fillStyle = '#2d5a2d'; ctx.beginPath(); ctx.arc(0, 0, this.radius, 0, Math.PI * 2); ctx.fill();
                    ctx.fillStyle = '#3e7a3e'; ctx.beginPath(); ctx.arc(-this.radius * 0.3, -this.radius * 0.3, this.radius * 0.4, 0, Math.PI * 2); ctx.fill();
                } else if (this.type === 'rock') {
                    ctx.fillStyle = '#555'; ctx.beginPath(); ctx.moveTo(this.points[0].x, this.points[0].y);
                    this.points.forEach(p => ctx.lineTo(p.x, p.y)); ctx.fill(); ctx.strokeStyle = '#666'; ctx.stroke();
                } else {
                    ctx.fillStyle = '#111'; ctx.fillRect(-this.radius, -this.radius, this.radius * 2, this.radius * 2);
                    ctx.fillStyle = '#444'; ctx.fillRect(-this.radius + 2, -this.radius + 2, this.radius * 2 - 4, this.radius * 2 - 4);
                }
                ctx.translate(-this.x, -this.y);
            }
        }

        class Unit {
            constructor(x, y, type) {
                this.x = x; this.y = y; this.type = type; this.selected = false;
                this.angle = Math.random() * Math.PI * 2;
                this.currentSpeed = 0; this.isBraking = false;

                // Pathfinding State
                this.path = []; // Array of waypoints
                this.currentTarget = null;

                if (type === 'tank') {
                    this.color = '#ccaa00'; this.radius = 28;
                    this.maxSpeed = 3.0; this.acceleration = 0.08; this.brakingForce = 0.15;
                    this.friction = 0.98; this.turnSpeed = 0.04; this.health = 100;
                } else {
                    this.color = '#aaaaaa'; this.radius = 10;
                    this.maxSpeed = 1.8; this.acceleration = 0.2; this.brakingForce = 0.3;
                    this.friction = 0.85; this.turnSpeed = 0.3; this.health = 30;
                }
            }
            update() {
                // Path Following Logic
                if (this.path.length > 0) {
                    // Look at next waypoint
                    const nextPoint = this.path[0];
                    const distToPoint = dist(this.x, this.y, nextPoint.x, nextPoint.y);

                    // If close to waypoint, remove it and move to next
                    if (distToPoint < 30) {
                        this.path.shift();
                    } else {
                        this.driveTo(nextPoint.x, nextPoint.y);
                    }
                } else if (this.currentTarget) {
                    // Final Approach
                    this.driveTo(this.currentTarget.x, this.currentTarget.y);
                } else {
                    // Idle friction
                    this.currentSpeed *= this.friction;
                    this.x += Math.cos(this.angle) * this.currentSpeed;
                    this.y += Math.sin(this.angle) * this.currentSpeed;
                }

                // Dust
                if (this.currentSpeed > 0.5 && this.type === 'tank' && !this.isBraking && Math.random() > 0.8) {
                    world.particles.push(new Dust(this.x - Math.cos(this.angle) * 15, this.y - Math.sin(this.angle) * 15));
                }
            }

            driveTo(tx, ty) {
                const d = dist(this.x, this.y, tx, ty);
                const targetAngle = Math.atan2(ty - this.y, tx - this.x);
                let diff = normalizeAngle(targetAngle - this.angle);

                if (Math.abs(diff) > this.turnSpeed && d > 5) this.angle += Math.sign(diff) * this.turnSpeed;
                else if (d > 5) this.angle = targetAngle;

                this.isBraking = false;
                let throttle = 0;
                // Stop only if this is the FINAL target (path empty)
                const isFinalTarget = (this.path.length === 0);
                const stoppingDist = (this.currentSpeed * this.currentSpeed) / (2 * this.brakingForce);

                if (isFinalTarget && (d < 5 || d < stoppingDist + 20)) {
                    this.isBraking = true;
                } else if (Math.abs(diff) > Math.PI / 4) {
                    this.isBraking = true; // Cornering brake
                } else {
                    throttle = 1;
                }

                if (this.isBraking) {
                    if (this.currentSpeed > 0) this.currentSpeed -= this.brakingForce;
                    if (this.currentSpeed < 0) this.currentSpeed = 0;
                } else if (this.currentSpeed < this.maxSpeed) {
                    this.currentSpeed += this.acceleration * throttle;
                }

                this.currentSpeed *= this.friction;
                this.x += Math.cos(this.angle) * this.currentSpeed;
                this.y += Math.sin(this.angle) * this.currentSpeed;
            }

            draw() {
                if (this.x < camera.x - 50 || this.x > camera.x + canvas.width + 50 ||
                    this.y < camera.y - 50 || this.y > camera.y + canvas.height + 50) return;

                // Draw Path Line (Debug)
                if (this.selected && this.path.length > 0) {
                    ctx.strokeStyle = 'rgba(0, 255, 0, 0.5)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    this.path.forEach(p => ctx.lineTo(p.x, p.y));
                    if (this.currentTarget) ctx.lineTo(this.currentTarget.x, this.currentTarget.y);
                    ctx.stroke();
                }

                ctx.translate(this.x, this.y);
                if (this.selected) {
                    ctx.strokeStyle = '#00ff00'; ctx.lineWidth = 1; ctx.beginPath();
                    ctx.arc(0, 0, this.radius + 2, 0, Math.PI * 2); ctx.stroke();
                    ctx.fillStyle = '#00ff00'; ctx.fillRect(-12, -this.radius - 8, 24 * (this.health / 100), 3);
                }
                ctx.rotate(this.angle);
                if (this.type === 'tank') {
                    ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.fillRect(-15, -10, 36, 28);
                    ctx.fillStyle = this.color; ctx.fillRect(-18, -14, 36, 28);
                    if (this.isBraking) {
                        ctx.fillStyle = '#ff0000'; ctx.shadowColor = '#ff0000'; ctx.shadowBlur = 10;
                        ctx.fillRect(-18, -12, 2, 6); ctx.fillRect(-18, 6, 2, 6); ctx.shadowBlur = 0;
                    }
                    ctx.fillStyle = '#080808'; ctx.fillRect(-18, -16, 36, 4); ctx.fillRect(-18, 12, 36, 4);
                    ctx.fillStyle = '#333';
                    for (let i = -16; i < 16; i += 4) { ctx.fillRect(i, -16, 1, 4); ctx.fillRect(i, 12, 1, 4); }
                    ctx.fillStyle = '#997700'; ctx.beginPath(); ctx.arc(-2, 0, 11, 0, Math.PI * 2); ctx.fill();
                    ctx.strokeStyle = '#886600'; ctx.lineWidth = 6; ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(26, 0); ctx.stroke();
                } else {
                    ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(0, 0, 6, 0, Math.PI * 2); ctx.fill();
                    ctx.fillStyle = '#222'; ctx.fillRect(0, -2, 10, 4);
                }
                ctx.rotate(-this.angle);
                ctx.translate(-this.x, -this.y);
            }

            setPath(path, finalX, finalY) {
                // Add scatter to final destination only
                const spread = 40;
                this.currentTarget = {
                    x: finalX + (Math.random() * spread - spread / 2),
                    y: finalY + (Math.random() * spread - spread / 2)
                };
                this.path = path;
            }
        }

        class Dust {
            constructor(x, y) { this.x = x; this.y = y; this.size = Math.random() * 5 + 2; this.life = 1.0; }
            update() { this.life -= 0.05; this.size += 0.2; }
            draw() {
                ctx.fillStyle = `rgba(150, 140, 100, ${this.life * 0.3})`;
                ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill();
            }
        }
        class MoveMarker {
            constructor(x, y) { this.x = x; this.y = y; this.life = 20; }
            update() { this.life--; }
            draw() {
                ctx.strokeStyle = '#00ff00'; ctx.lineWidth = 2; ctx.beginPath();
                ctx.moveTo(this.x - 5, this.y - 5); ctx.lineTo(this.x + 5, this.y + 5);
                ctx.moveTo(this.x + 5, this.y - 5); ctx.lineTo(this.x - 5, this.y + 5); ctx.stroke();
            }
        }

        // --- World Engine ---
        class World {
            constructor() {
                this.grid = new Grid(WORLD_W, WORLD_H, GRID_SIZE);
                this.units = [];
                this.obstacles = [];
                this.particles = [];
                this.generateMap();
            }

            generateMap() {
                // Forests
                for (let i = 0; i < 40; i++) {
                    const cx = Math.random() * WORLD_W; const cy = Math.random() * WORLD_H;
                    for (let j = 0; j < 10; j++) {
                        const tx = cx + Math.random() * 200 - 100; const ty = cy + Math.random() * 200 - 100;
                        this.addObstacle(new Obstacle(tx, ty, 15 + Math.random() * 15, 'tree'));
                    }
                }
                // Rocks & Buildings
                for (let i = 0; i < 30; i++) this.addObstacle(new Obstacle(Math.random() * WORLD_W, Math.random() * WORLD_H, 30 + Math.random() * 30, 'rock'));
                for (let i = 0; i < 15; i++) this.addObstacle(new Obstacle(Math.random() * WORLD_W, Math.random() * WORLD_H, 60 + Math.random() * 20, 'building'));

                // Clear spawn
                this.obstacles = this.obstacles.filter(o => dist(o.x, o.y, 1000, 1000) > 300);

                // Re-build grid based on final obstacles
                this.obstacles.forEach(o => this.grid.markObstacle(o.x, o.y, o.radius));
            }

            addObstacle(obs) {
                this.obstacles.push(obs);
            }

            resolveCollisions() {
                for (let i = 0; i < this.units.length; i++) {
                    for (let j = i + 1; j < this.units.length; j++) {
                        const u1 = this.units[i]; const u2 = this.units[j];
                        const d = dist(u1.x, u1.y, u2.x, u2.y);
                        const minD = u1.radius + u2.radius;
                        if (d < minD) {
                            const overlap = minD - d;
                            const angle = Math.atan2(u1.y - u2.y, u1.x - u2.x);
                            const force = overlap * 0.1;
                            const px = Math.cos(angle) * force; const py = Math.sin(angle) * force;
                            u1.x += px; u1.y += py; u2.x -= px; u2.y -= py;
                            u1.currentSpeed *= 0.95; u2.currentSpeed *= 0.95;
                        }
                    }
                }
                for (let u of this.units) {
                    for (let o of this.obstacles) {
                        const d = dist(u.x, u.y, o.x, o.y);
                        const minD = u.radius + o.radius;
                        if (d < minD) {
                            const overlap = minD - d;
                            const angle = Math.atan2(u.y - o.y, u.x - o.x);
                            u.x += Math.cos(angle) * overlap;
                            u.y += Math.sin(angle) * overlap;
                            u.currentSpeed *= 0.8;
                        }
                    }
                }
            }

            trySpawn(type) {
                const rx = camera.x + canvas.width / 2 + (Math.random() * 200 - 100);
                const ry = camera.y + canvas.height / 2 + (Math.random() * 200 - 100);
                this.units.push(new Unit(rx, ry, type));
            }

            update() {
                this.units.forEach(u => u.update());
                this.resolveCollisions();
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    this.particles[i].update();
                    if (this.particles[i].life <= 0) this.particles.splice(i, 1);
                }
            }

            draw() {
                // Grid Debug (Blocked cells)
                // Comment this block out if you don't want to see the red squares
                ctx.fillStyle = 'rgba(255, 0, 0, 0.1)';
                for (let y = Math.floor(camera.y / GRID_SIZE); y < (camera.y + canvas.height) / GRID_SIZE; y++) {
                    for (let x = Math.floor(camera.x / GRID_SIZE); x < (camera.x + canvas.width) / GRID_SIZE; x++) {
                        if (this.grid.grid[y] && this.grid.grid[y][x] === 1) {
                            ctx.fillRect(x * GRID_SIZE, y * GRID_SIZE, GRID_SIZE, GRID_SIZE);
                        }
                    }
                }

                ctx.strokeStyle = '#35454d'; ctx.lineWidth = 1; ctx.beginPath();
                const startX = Math.floor(camera.x / 100) * 100;
                const startY = Math.floor(camera.y / 100) * 100;
                for (let x = startX; x < camera.x + canvas.width; x += 100) { ctx.moveTo(x, camera.y); ctx.lineTo(x, camera.y + canvas.height); }
                for (let y = startY; y < camera.y + canvas.height; y += 100) { ctx.moveTo(camera.x, y); ctx.lineTo(camera.x + canvas.width, y); }
                ctx.stroke();

                ctx.strokeStyle = '#ff0000'; ctx.lineWidth = 5; ctx.strokeRect(0, 0, WORLD_W, WORLD_H);

                this.obstacles.forEach(o => {
                    if (o.x > camera.x - 100 && o.x < camera.x + canvas.width + 100 &&
                        o.y > camera.y - 100 && o.y < camera.y + canvas.height + 100) o.draw();
                });
                this.particles.forEach(p => p.draw());
                this.units.forEach(u => u.draw());
            }

            updateRadar() {
                radar.innerHTML = '';
                const sx = 250 / WORLD_W; const sy = 200 / WORLD_H;
                const vDiv = document.createElement('div');
                vDiv.style.position = 'absolute'; vDiv.style.border = '1px solid white';
                vDiv.style.left = (camera.x * sx) + 'px'; vDiv.style.top = (camera.y * sy) + 'px';
                vDiv.style.width = (canvas.width * sx) + 'px'; vDiv.style.height = (canvas.height * sy) + 'px';
                radar.appendChild(vDiv);
                this.units.forEach(u => {
                    const d = document.createElement('div'); d.className = 'radar-dot';
                    if (u.type === 'tank') d.style.background = 'gold';
                    d.style.left = (u.x * sx) + 'px'; d.style.top = (u.y * sy) + 'px';
                    radar.appendChild(d);
                });
            }
        }

        // --- Input Handling ---
        const world = new World();
        const camera = new Camera();
        let mouseScreenX = 0, mouseScreenY = 0;
        let isDragging = false;
        let startWorldX, startWorldY;

        window.addEventListener('mousemove', e => {
            const rect = canvas.getBoundingClientRect();
            mouseScreenX = e.clientX - rect.left;
            mouseScreenY = e.clientY - rect.top;
            if (isDragging) {
                const worldX = mouseScreenX + camera.x; const worldY = mouseScreenY + camera.y;
                const w = worldX - startWorldX; const h = worldY - startWorldY;
                selectionBox.style.width = Math.abs(w) + 'px'; selectionBox.style.height = Math.abs(h) + 'px';
                selectionBox.style.left = (w < 0 ? mouseScreenX : mouseScreenX - w) + 'px';
                selectionBox.style.top = (h < 0 ? mouseScreenY : mouseScreenY - h) + 'px';
            }
        });

        canvas.addEventListener('mousedown', e => {
            if (e.button !== 0) return;
            isDragging = true; camera.target = null;
            startWorldX = mouseScreenX + camera.x; startWorldY = mouseScreenY + camera.y;
            selectionBox.style.display = 'block';
            selectionBox.style.left = mouseScreenX + 'px'; selectionBox.style.top = mouseScreenY + 'px';
            selectionBox.style.width = '0'; selectionBox.style.height = '0';
        });

        canvas.addEventListener('mouseup', e => {
            if (e.button !== 0) return;
            isDragging = false; selectionBox.style.display = 'none';
            const endWorldX = mouseScreenX + camera.x; const endWorldY = mouseScreenY + camera.y;
            const x1 = Math.min(startWorldX, endWorldX); const y1 = Math.min(startWorldY, endWorldY);
            const x2 = Math.max(startWorldX, endWorldX); const y2 = Math.max(startWorldY, endWorldY);
            world.units.forEach(u => u.selected = false);
            if (Math.abs(x2 - x1) > 5 || Math.abs(y2 - y1) > 5) {
                world.units.forEach(u => { if (u.x > x1 && u.x < x2 && u.y > y1 && u.y < y2) u.selected = true; });
            } else {
                world.units.forEach(u => { if (dist(u.x, u.y, endWorldX, endWorldY) < u.radius + 5) u.selected = true; });
            }
        });

        window.addEventListener('contextmenu', e => {
            e.preventDefault();
            const worldX = mouseScreenX + camera.x;
            const worldY = mouseScreenY + camera.y;
            world.particles.push(new MoveMarker(worldX, worldY));

            // Calculate Path for Selected Units
            world.units.forEach(u => {
                if (u.selected) {
                    // Calculate path on grid
                    const path = world.grid.findPath(u.x, u.y, worldX, worldY);
                    u.setPath(path, worldX, worldY);
                }
            });
        });

        window.addEventListener('keydown', e => {
            if (e.code === 'Space') {
                const selected = world.units.find(u => u.selected);
                camera.target = selected ? selected : null;
            }
        });

        let tick = 0;
        function loop() {
            camera.update();
            world.update();
            ctx.fillStyle = '#2b3a42'; ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.save(); ctx.translate(-camera.x, -camera.y);
            world.draw();
            ctx.restore();
            if (tick++ % 10 === 0) world.updateRadar();
            requestAnimationFrame(loop);
        }

        world.trySpawn('tank'); world.trySpawn('tank'); world.trySpawn('soldier');
        loop();

    </script>
</body>

</html>