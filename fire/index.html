<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGL Fast Fire & Visible Background</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
        }

        canvas {
            display: block;
        }

        #instructions {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            color: rgba(255, 255, 255, 0.9);
            font-family: sans-serif;
            pointer-events: none;
            user-select: none;
            text-shadow: 0 2px 4px black;
            font-weight: bold;
        }
    </style>
</head>

<body>
    <!-- <div id="instructions">Fast Decay + Visible Background</div> -->
    <canvas id="glCanvas"></canvas>

    <!-- ========================================== -->
    <!--        BACKGROUND SHADERS (ROCKS)          -->
    <!-- ========================================== -->
    <script id="bg-vs" type="x-shader/x-vertex">
        attribute vec2 a_position;
        void main() { gl_Position = vec4(a_position, 0.0, 1.0); }
    </script>

    <script id="bg-fs" type="x-shader/x-fragment">
        precision highp float;
        uniform vec2 u_resolution;
        uniform vec2 u_lightPos;
        uniform float u_time;

        vec2 hash2(vec2 p) {
            p = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)));
            return -1.0 + 2.0 * fract(sin(p) * 43758.5453123);
        }
        float noise(vec2 p) {
            vec2 i = floor(p); vec2 f = fract(p); vec2 u = f*f*(3.0-2.0*f);
            return mix(mix(dot(hash2(i + vec2(0.0,0.0)), f - vec2(0.0,0.0)),
                           dot(hash2(i + vec2(1.0,0.0)), f - vec2(1.0,0.0)), u.x),
                       mix(dot(hash2(i + vec2(0.0,1.0)), f - vec2(0.0,1.0)),
                           dot(hash2(i + vec2(1.0,1.0)), f - vec2(1.0,1.0)), u.x), u.y);
        }
        float fbm(vec2 p) {
            float v = 0.0; float a = 0.5; mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.5));
            for (int i = 0; i < 5; ++i) { v += a * noise(p); p = rot * p * 2.0; a *= 0.5; }
            return v;
        }
        vec2 voronoi(vec2 x) {
            vec2 n = floor(x); vec2 f = fract(x); vec2 mg, mr; float md = 8.0;
            for(int j=-1; j<=1; j++) {
                for(int i=-1; i<=1; i++) {
                    vec2 g = vec2(float(i), float(j));
                    vec2 o = hash2(n + g) * 0.5 + 0.5;
                    vec2 r = g + o - f;
                    float d = dot(r, r);
                    if(d < md) { md = d; mr = r; mg = g; }
                }
            }
            return vec2(sqrt(md), hash2(n + mg).x); 
        }
        float getHeight(vec2 uv) {
            vec2 warpedUV = uv + fbm(uv * 3.0) * 0.1;
            vec2 rockData = voronoi(warpedUV * 6.0);
            float h = 1.0 - rockData.x;
            h = smoothstep(0.0, 0.9, h); h = pow(h, 0.5); 
            h += fbm(uv * 20.0) * 0.1 * h;
            return clamp(h, 0.0, 1.0);
        }

        void main() {
            vec2 uv = gl_FragCoord.xy / u_resolution;
            uv.x *= u_resolution.x / u_resolution.y;
            float h = getHeight(uv);
            float eps = 2.0 / u_resolution.y;
            float h_r = getHeight(uv + vec2(eps, 0.0));
            float h_u = getHeight(uv + vec2(0.0, eps));
            vec3 norm = normalize(cross(vec3(eps, 0.0, (h_r-h)*3.0), vec3(0.0, eps, (h_u-h)*3.0)));

            // Colors
            vec3 colDark = vec3(0.05, 0.05, 0.08);
            vec3 rockBase = vec3(0.2, 0.2, 0.25) * (0.8 + 0.4 * voronoi(uv + fbm(uv*3.0)*0.1 * 6.0).y);
            vec3 albedo = mix(colDark, rockBase, smoothstep(0.1, 0.4, h));
            
            float isWater = 1.0 - smoothstep(0.05, 0.2, h);
            float wetness = isWater + (smoothstep(0.2, 1.0, h) * 0.4);

            vec2 lUV = u_lightPos / u_resolution; lUV.x *= u_resolution.x / u_resolution.y;
            vec3 lDir = normalize(vec3(lUV, 0.5) - vec3(uv, 0.0));
            float dist = length(vec3(lUV, 0.5) - vec3(uv, 0.0));
            
            // --- NEW LIGHTING MODEL ---
            float flicker = (1.0 + sin(u_time*20.0)*0.1 + sin(u_time*53.0)*0.05);
            
            // 1. The Core: Super tight, super bright (500.0 falloff)
            float coreLight = 1.0 / (0.1 + 500.0 * dist * dist);
            
            // 2. The Glow: Wide, soft light (2.0 falloff) so we see the rocks
            float ambientGlow = 1.0 / (1.0 + 2.0 * dist * dist);
            
            // Combine
            float att = (coreLight * 1.5 + ambientGlow * 0.6) * flicker;

            float diff = max(dot(norm, lDir), 0.0);
            vec3 spec = vec3(1.0, 0.9, 0.8) * pow(max(dot(vec3(0,0,1), reflect(-lDir, norm)), 0.0), mix(30.0, 200.0, isWater)) * att * mix(1.0, 3.0, isWater) * wetness;
            
            // Increased Ambient slightly for better visibility
            vec3 ambientColor = vec3(0.06, 0.06, 0.09);
            
            gl_FragColor = vec4(ambientColor + (diff * vec3(1.6, 0.8, 0.3) * att * albedo) + spec, 1.0);
        }
    </script>

    <!-- ========================================== -->
    <!--      IMPROVED FIRE SHADERS (TEXTURED)      -->
    <!-- ========================================== -->

    <script id="fire-vs" type="x-shader/x-vertex">
        attribute vec2 a_position;
        attribute float a_life;
        attribute float a_size;
        attribute float a_random;
        uniform vec2 u_resolution;
        varying float v_life;
        varying float v_random;
        void main() {
            vec2 zeroToOne = a_position / u_resolution;
            vec2 zeroToTwo = zeroToOne * 2.0;
            vec2 clipSpace = zeroToTwo - 1.0;
            gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);
            gl_PointSize = a_size * (0.5 + a_life); 
            v_life = a_life;
            v_random = a_random;
        }
    </script>

    <script id="fire-fs" type="x-shader/x-fragment">
        precision mediump float;
        varying float v_life;
        varying float v_random;
        float rand(vec2 co){ return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453); }
        void main() {
            vec2 coord = gl_PointCoord;
            float noise = rand(coord + vec2(v_random, v_life)); 
            float dist = length(coord - 0.5);
            float erosion = noise * 0.3 * (1.0 - v_life);
            float alpha = 1.0 - (dist * 2.0);
            alpha -= erosion;
            alpha = clamp(alpha, 0.0, 1.0);
            alpha = pow(alpha, 2.0); 
            if (alpha < 0.01) discard;

            vec3 colorOut;
            bool isSpark = (v_random > 0.9); 
            if (isSpark) {
                colorOut = mix(vec3(1.0, 0.5, 0.0), vec3(1.0, 1.0, 1.0), v_life);
                alpha *= 1.5; 
            } else {
                if (v_life > 0.9) colorOut = mix(vec3(1.0, 1.0, 0.5), vec3(0.8, 0.9, 1.0), (v_life - 0.9) * 10.0);
                else if (v_life > 0.6) colorOut = mix(vec3(1.0, 0.5, 0.0), vec3(1.0, 1.0, 0.2), (v_life - 0.6) * 3.3);
                else if (v_life > 0.3) colorOut = mix(vec3(0.8, 0.1, 0.0), vec3(1.0, 0.5, 0.0), (v_life - 0.3) * 3.3);
                else colorOut = mix(vec3(0.1, 0.0, 0.0), vec3(0.8, 0.1, 0.0), v_life * 3.3);
            }
            gl_FragColor = vec4(colorOut, alpha * v_life);
        }
    </script>

    <!-- ========================================== -->
    <!--               JAVASCRIPT LOGIC             -->
    <!-- ========================================== -->

    <script>
        const canvas = document.getElementById("glCanvas");
        const gl = canvas.getContext("webgl");

        function createProgram(gl, vsId, fsId) {
            const vsSrc = document.getElementById(vsId).text;
            const fsSrc = document.getElementById(fsId).text;
            const vs = gl.createShader(gl.VERTEX_SHADER);
            const fs = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(vs, vsSrc); gl.compileShader(vs);
            gl.shaderSource(fs, fsSrc); gl.compileShader(fs);
            if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS)) { console.error(gl.getShaderInfoLog(fs)); return null; }
            const prog = gl.createProgram();
            gl.attachShader(prog, vs); gl.attachShader(prog, fs);
            gl.linkProgram(prog);
            return prog;
        }

        const bgProgram = createProgram(gl, "bg-vs", "bg-fs");
        const fireProgram = createProgram(gl, "fire-vs", "fire-fs");

        const bgBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, bgBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1]), gl.STATIC_DRAW);
        const bgLocs = { pos: gl.getAttribLocation(bgProgram, "a_position"), res: gl.getUniformLocation(bgProgram, "u_resolution"), light: gl.getUniformLocation(bgProgram, "u_lightPos"), time: gl.getUniformLocation(bgProgram, "u_time") };

        const PARTICLE_COUNT = 1600;
        const DATA_PER_PARTICLE = 5;
        const particlesData = new Float32Array(PARTICLE_COUNT * DATA_PER_PARTICLE);
        const particles = [];

        for (let i = 0; i < PARTICLE_COUNT; i++) {
            particles.push({ x: 0, y: 0, vx: 0, vy: 0, life: 0, decay: 0, size: 0, seed: Math.random() });
        }

        const fireBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, fireBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, particlesData.byteLength, gl.DYNAMIC_DRAW);

        const fireLocs = {
            pos: gl.getAttribLocation(fireProgram, "a_position"),
            life: gl.getAttribLocation(fireProgram, "a_life"),
            size: gl.getAttribLocation(fireProgram, "a_size"),
            random: gl.getAttribLocation(fireProgram, "a_random"),
            res: gl.getUniformLocation(fireProgram, "u_resolution")
        };

        let mouseX = window.innerWidth / 2;
        let mouseY = window.innerHeight * 0.75;
        let time = 0;
        function updateMouse(x, y) { mouseX = x; mouseY = y; }
        window.addEventListener('mousemove', e => updateMouse(e.clientX, e.clientY));
        window.addEventListener('touchmove', e => { e.preventDefault(); updateMouse(e.touches[0].clientX, e.touches[0].clientY); }, { passive: false });

        function resetParticle(p) {
            p.x = mouseX;
            p.y = mouseY;

            const isSpark = Math.random() > 0.9;
            p.seed = isSpark ? 0.95 : Math.random() * 0.8;

            if (isSpark) {
                const angle = (Math.random() * Math.PI) + Math.PI;
                const speed = 2.0 + Math.random() * 5.0;
                p.vx = Math.cos(angle) * speed * 0.5;
                p.vy = -Math.abs(Math.sin(angle) * speed);
                p.life = 1.0;
                p.decay = 0.04 + Math.random() * 0.04;
                p.size = 3.0 + Math.random() * 4.0;
                p.x += (Math.random() - 0.5) * 20;
            } else {
                const spread = 5;
                p.x += (Math.random() - 0.5) * spread;
                p.y += (Math.random() - 0.5) * spread * 0.5;

                p.vx = (Math.random() - 0.5) * 0.5;

                // --- PHYSICS UPDATE ---
                // High Velocity: -3.0 to -5.0 pixels per frame (Shoots up fast)
                p.vy = -3.0 - Math.random() * 2.0;

                p.life = 1.0;
                // --- PHYSICS UPDATE ---
                // High Decay: Dies in ~20-30 frames (Very short trail)
                p.decay = 0.03 + Math.random() * 0.04;

                // Increased size slightly so the flame still looks "thick" despite being short
                p.size = 45 + Math.random() * 45;
            }
        }

        function animate() {
            time += 0.015;
            if (canvas.width !== window.innerWidth || canvas.height !== window.innerHeight) {
                canvas.width = window.innerWidth; canvas.height = window.innerHeight;
                gl.viewport(0, 0, canvas.width, canvas.height);
            }

            gl.disable(gl.BLEND);
            gl.useProgram(bgProgram);
            gl.bindBuffer(gl.ARRAY_BUFFER, bgBuffer);
            gl.enableVertexAttribArray(bgLocs.pos);
            gl.vertexAttribPointer(bgLocs.pos, 2, gl.FLOAT, false, 0, 0);
            gl.uniform2f(bgLocs.res, canvas.width, canvas.height);
            gl.uniform2f(bgLocs.light, mouseX, canvas.height - mouseY);
            gl.uniform1f(bgLocs.time, time);
            gl.drawArrays(gl.TRIANGLES, 0, 6);

            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
            gl.useProgram(fireProgram);

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const p = particles[i];
                if (p.life <= 0) resetParticle(p);

                if (p.seed > 0.9) {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vy += 0.05;
                } else {
                    p.x += p.vx;
                    p.y += p.vy;

                    // Acceleration
                    p.vy -= 0.1;

                    floatTargetX = mouseX + (Math.sin(time * 2.0 + p.y * 0.01) * 10.0);
                    p.vx += (mouseX - p.x) * 0.001; // Stronger pull to mouse X
                    p.x += Math.sin(time * 5.0 + p.y * 0.1) * 0.5;
                }

                p.life -= p.decay;

                const index = i * DATA_PER_PARTICLE;
                particlesData[index] = p.x;
                particlesData[index + 1] = p.y;
                particlesData[index + 2] = p.life < 0 ? 0 : p.life;
                particlesData[index + 3] = p.size;
                particlesData[index + 4] = p.seed;
            }

            gl.bindBuffer(gl.ARRAY_BUFFER, fireBuffer);
            gl.bufferSubData(gl.ARRAY_BUFFER, 0, particlesData);

            const stride = DATA_PER_PARTICLE * 4;
            gl.enableVertexAttribArray(fireLocs.pos);
            gl.vertexAttribPointer(fireLocs.pos, 2, gl.FLOAT, false, stride, 0);
            gl.enableVertexAttribArray(fireLocs.life);
            gl.vertexAttribPointer(fireLocs.life, 1, gl.FLOAT, false, stride, 8);
            gl.enableVertexAttribArray(fireLocs.size);
            gl.vertexAttribPointer(fireLocs.size, 1, gl.FLOAT, false, stride, 12);
            gl.enableVertexAttribArray(fireLocs.random);
            gl.vertexAttribPointer(fireLocs.random, 1, gl.FLOAT, false, stride, 16);
            gl.uniform2f(fireLocs.res, canvas.width, canvas.height);
            gl.drawArrays(gl.POINTS, 0, PARTICLE_COUNT);

            requestAnimationFrame(animate);
        }
        animate();
    </script>
</body>

</html>