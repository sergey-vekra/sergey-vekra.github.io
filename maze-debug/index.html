<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>WebGL2 Rotating Cube</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #333;
        }

        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
    </style>
</head>

<body>
    <canvas id="glcanvas"></canvas>

    <!-- VERTEX SHADER (GLSL 3.00 ES) -->
    <script id="vertex-shader" type="x-shader/x-vertex">
        #version 300 es
        
        // Input attributes
        in vec4 a_position;
        in vec4 a_color;

        // Uniform transformation matrix
        uniform mat4 u_matrix;

        // Output to fragment shader
        out vec4 v_color;

        void main() {
            // Multiply the position by the matrix.
            gl_Position = u_matrix * a_position;
            
            // Pass the color to the fragment shader.
            v_color = a_color;
        }
    </script>

    <!-- FRAGMENT SHADER (GLSL 3.00 ES) -->
    <script id="fragment-shader" type="x-shader/x-fragment">
        #version 300 es
        
        precision mediump float;

        // Input from vertex shader
        in vec4 v_color;

        // Output color
        out vec4 outColor;

        void main() {
            outColor = v_color;
        }
    </script>

    <script>
        "use strict";

        function main() {
            // 1. Get Context
            const canvas = document.getElementById("glcanvas");
            const gl = canvas.getContext("webgl2");
            if (!gl) { return alert("WebGL2 not supported"); }

            // 2. Compile Shaders
            const vsSource = document.getElementById("vertex-shader").text.trim();
            const fsSource = document.getElementById("fragment-shader").text.trim();
            const program = createProgram(gl, vsSource, fsSource);

            // 3. Look up locations
            const positionLoc = gl.getAttribLocation(program, "a_position");
            const colorLoc = gl.getAttribLocation(program, "a_color");
            const matrixLoc = gl.getUniformLocation(program, "u_matrix");

            // 4. Define Geometry (Cube)
            // 6 faces * 2 triangles * 3 vertices = 36 vertices
            // X, Y, Z
            const positions = new Float32Array([
                // Front face
                -0.5, -0.5, 0.5, 0.5, -0.5, 0.5, 0.5, 0.5, 0.5,
                -0.5, -0.5, 0.5, 0.5, 0.5, 0.5, -0.5, 0.5, 0.5,
                // Back face
                -0.5, -0.5, -0.5, -0.5, 0.5, -0.5, 0.5, 0.5, -0.5,
                -0.5, -0.5, -0.5, 0.5, 0.5, -0.5, 0.5, -0.5, -0.5,
                // Top face
                -0.5, 0.5, -0.5, -0.5, 0.5, 0.5, 0.5, 0.5, 0.5,
                -0.5, 0.5, -0.5, 0.5, 0.5, 0.5, 0.5, 0.5, -0.5,
                // Bottom face
                -0.5, -0.5, -0.5, 0.5, -0.5, -0.5, 0.5, -0.5, 0.5,
                -0.5, -0.5, -0.5, 0.5, -0.5, 0.5, -0.5, -0.5, 0.5,
                // Right face
                0.5, -0.5, -0.5, 0.5, 0.5, -0.5, 0.5, 0.5, 0.5,
                0.5, -0.5, -0.5, 0.5, 0.5, 0.5, 0.5, -0.5, 0.5,
                // Left face
                -0.5, -0.5, -0.5, -0.5, -0.5, 0.5, -0.5, 0.5, 0.5,
                -0.5, -0.5, -0.5, -0.5, 0.5, 0.5, -0.5, 0.5, -0.5,
            ]);

            // R, G, B for each vertex
            const colors = new Float32Array([
                // Front - Red
                1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0,
                // Back - Green
                0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0,
                // Top - Blue
                0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1,
                // Bottom - Yellow
                1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0,
                // Right - Cyan
                0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1,
                // Left - Magenta
                1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1,
            ]);

            // 5. Setup Vertex Array Object (VAO)
            const vao = gl.createVertexArray();
            gl.bindVertexArray(vao);

            // Buffer Positions
            const positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);
            gl.enableVertexAttribArray(positionLoc);
            gl.vertexAttribPointer(positionLoc, 3, gl.FLOAT, false, 0, 0);

            // Buffer Colors
            const colorBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);
            gl.enableVertexAttribArray(colorLoc);
            gl.vertexAttribPointer(colorLoc, 3, gl.FLOAT, false, 0, 0);

            // 6. Setup Rendering Settings
            gl.enable(gl.DEPTH_TEST);
            gl.enable(gl.CULL_FACE); // Don't draw back-facing triangles

            // 7. Animation Loop
            let then = 0;
            let rotationX = 0;
            let rotationY = 0;

            function render(now) {
                now *= 0.001; // Convert to seconds
                const deltaTime = now - then;
                then = now;

                // Resize canvas to fit screen
                if (canvas.width !== canvas.clientWidth || canvas.height !== canvas.clientHeight) {
                    canvas.width = canvas.clientWidth;
                    canvas.height = canvas.clientHeight;
                    gl.viewport(0, 0, canvas.width, canvas.height);
                }

                // Clear screen
                gl.clearColor(0.2, 0.2, 0.2, 1.0);
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

                gl.useProgram(program);
                gl.bindVertexArray(vao);

                // Update Rotation
                rotationX += deltaTime;
                rotationY += deltaTime * 0.7;

                // Compute Matrix
                const aspect = canvas.clientWidth / canvas.clientHeight;
                const projectionMatrix = m4.perspective(Math.PI / 4, aspect, 0.1, 100);

                // Move camera back (Translate Z) -> Rotate X -> Rotate Y
                let matrix = m4.translate(projectionMatrix, 0, 0, -3);
                matrix = m4.xRotate(matrix, rotationX);
                matrix = m4.yRotate(matrix, rotationY);

                // Set Uniform
                gl.uniformMatrix4fv(matrixLoc, false, matrix);

                // Draw
                gl.drawArrays(gl.TRIANGLES, 0, 36);

                requestAnimationFrame(render);
            }
            requestAnimationFrame(render);
        }

        // --- Helper: Shader Compilation ---
        function createProgram(gl, vsSource, fsSource) {
            const vs = compileShader(gl, gl.VERTEX_SHADER, vsSource);
            const fs = compileShader(gl, gl.FRAGMENT_SHADER, fsSource);
            const program = gl.createProgram();
            gl.attachShader(program, vs);
            gl.attachShader(program, fs);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error(gl.getProgramInfoLog(program));
                gl.deleteProgram(program);
                return null;
            }
            return program;
        }

        function compileShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        // --- Helper: Minimal Matrix Math (Column Major) ---
        const m4 = {
            perspective: function (fieldOfViewInRadians, aspect, near, far) {
                const f = Math.tan(Math.PI * 0.5 - 0.5 * fieldOfViewInRadians);
                const rangeInv = 1.0 / (near - far);
                return [
                    f / aspect, 0, 0, 0,
                    0, f, 0, 0,
                    0, 0, (near + far) * rangeInv, -1,
                    0, 0, near * far * rangeInv * 2, 0
                ];
            },
            translate: function (m, tx, ty, tz) {
                return [
                    m[0], m[1], m[2], m[3],
                    m[4], m[5], m[6], m[7],
                    m[8], m[9], m[10], m[11],
                    m[0] * tx + m[4] * ty + m[8] * tz + m[12],
                    m[1] * tx + m[5] * ty + m[9] * tz + m[13],
                    m[2] * tx + m[6] * ty + m[10] * tz + m[14],
                    m[3] * tx + m[7] * ty + m[11] * tz + m[15],
                ];
            },
            xRotate: function (m, angleInRadians) {
                const c = Math.cos(angleInRadians);
                const s = Math.sin(angleInRadians);
                return [
                    m[0], m[1], m[2], m[3],
                    m[4] * c + m[8] * s, m[5] * c + m[9] * s, m[6] * c + m[10] * s, m[7] * c + m[11] * s,
                    m[4] * -s + m[8] * c, m[5] * -s + m[9] * c, m[6] * -s + m[10] * c, m[7] * -s + m[11] * c,
                    m[12], m[13], m[14], m[15],
                ];
            },
            yRotate: function (m, angleInRadians) {
                const c = Math.cos(angleInRadians);
                const s = Math.sin(angleInRadians);
                return [
                    m[0] * c + m[8] * -s, m[1] * c + m[9] * -s, m[2] * c + m[10] * -s, m[3] * c + m[11] * -s,
                    m[4], m[5], m[6], m[7],
                    m[0] * s + m[8] * c, m[1] * s + m[9] * c, m[2] * s + m[10] * c, m[3] * s + m[11] * c,
                    m[12], m[13], m[14], m[15],
                ];
            },
        };

        // Start
        main();
    </script>
</body>

</html>