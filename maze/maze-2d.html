<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>3D Infinite Maze - No External Libraries</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #111;
            font-family: monospace;
        }

        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #00ffcc;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            pointer-events: none;
            border: 1px solid #00ffcc;
            line-height: 1.5em;
        }
    </style>
</head>

<body>
    <div id="ui">
        <b>Navigator Enhanced</b><br>
        Pos: <span id="pos">0, 0</span><br>
        <hr>
        <b>W</b> : Move Forward<br>
        <b>S</b> : Move Backward<br>
        <b>A</b> : Turn Left<br>
        <b>D</b> : Turn Right
    </div>
    <canvas id="glCanvas"></canvas>

    <script>
        // ==========================================
        // 0. MATH HELPERS (Replaces gl-matrix)
        // ==========================================
        const Mat4 = {
            create: function () {
                return new Float32Array([
                    1, 0, 0, 0,
                    0, 1, 0, 0,
                    0, 0, 1, 0,
                    0, 0, 0, 1
                ]);
            },
            perspective: function (out, fovy, aspect, near, far) {
                const f = 1.0 / Math.tan(fovy / 2);
                const nf = 1 / (near - far);
                out[0] = f / aspect;
                out[1] = 0;
                out[2] = 0;
                out[3] = 0;
                out[4] = 0;
                out[5] = f;
                out[6] = 0;
                out[7] = 0;
                out[8] = 0;
                out[9] = 0;
                out[10] = (far + near) * nf;
                out[11] = -1;
                out[12] = 0;
                out[13] = 0;
                out[14] = (2 * far * near) * nf;
                out[15] = 0;
                return out;
            },
            lookAt: function (out, eye, center, up) {
                let x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
                let eyex = eye[0], eyey = eye[1], eyez = eye[2];
                let upx = up[0], upy = up[1], upz = up[2];
                let centerx = center[0], centery = center[1], centerz = center[2];

                // z = normalize(eye - center)
                z0 = eyex - centerx; z1 = eyey - centery; z2 = eyez - centerz;
                len = 1 / Math.hypot(z0, z1, z2);
                z0 *= len; z1 *= len; z2 *= len;

                // x = normalize(cross(up, z))
                x0 = upy * z2 - upz * z1;
                x1 = upz * z0 - upx * z2;
                x2 = upx * z1 - upy * z0;
                len = Math.hypot(x0, x1, x2);
                if (!len) { x0 = 0; x1 = 0; x2 = 0; } else { len = 1 / len; x0 *= len; x1 *= len; x2 *= len; }

                // y = cross(z, x)
                y0 = z1 * x2 - z2 * x1;
                y1 = z2 * x0 - z0 * x2;
                y2 = z0 * x1 - z1 * x0;
                len = Math.hypot(y0, y1, y2);
                if (!len) { y0 = 0; y1 = 0; y2 = 0; } else { len = 1 / len; y0 *= len; y1 *= len; y2 *= len; }

                out[0] = x0; out[1] = y0; out[2] = z0; out[3] = 0;
                out[4] = x1; out[5] = y1; out[6] = z1; out[7] = 0;
                out[8] = x2; out[9] = y2; out[10] = z2; out[11] = 0;
                out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
                out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
                out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
                out[15] = 1;
                return out;
            },
            translate: function (out, a, v) {
                let x = v[0], y = v[1], z = v[2];
                let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
                let a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
                let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
                let a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

                out[0] = a00; out[1] = a01; out[2] = a02; out[3] = a03;
                out[4] = a10; out[5] = a11; out[6] = a12; out[7] = a13;
                out[8] = a20; out[9] = a21; out[10] = a22; out[11] = a23;
                out[12] = a00 * x + a10 * y + a20 * z + a30;
                out[13] = a01 * x + a11 * y + a21 * z + a31;
                out[14] = a02 * x + a12 * y + a22 * z + a32;
                out[15] = a03 * x + a13 * y + a23 * z + a33;
                return out;
            },
            scale: function (out, a, v) {
                let x = v[0], y = v[1], z = v[2];
                out[0] = a[0] * x; out[1] = a[1] * x; out[2] = a[2] * x; out[3] = a[3] * x;
                out[4] = a[4] * y; out[5] = a[5] * y; out[6] = a[6] * y; out[7] = a[7] * y;
                out[8] = a[8] * z; out[9] = a[9] * z; out[10] = a[10] * z; out[11] = a[11] * z;
                out[12] = a[12]; out[13] = a[13]; out[14] = a[14]; out[15] = a[15];
                return out;
            },
            rotateY: function (out, a, rad) {
                let s = Math.sin(rad), c = Math.cos(rad);
                let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
                let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];

                if (a !== out) { // Copy other rows if not in-place
                    out[4] = a[4]; out[5] = a[5]; out[6] = a[6]; out[7] = a[7];
                    out[12] = a[12]; out[13] = a[13]; out[14] = a[14]; out[15] = a[15];
                }

                out[0] = a00 * c - a20 * s;
                out[1] = a01 * c - a21 * s;
                out[2] = a02 * c - a22 * s;
                out[3] = a03 * c - a23 * s;
                out[8] = a00 * s + a20 * c;
                out[9] = a01 * s + a21 * c;
                out[10] = a02 * s + a22 * c;
                out[11] = a03 * s + a23 * c;
                return out;
            }
        };

        // ==========================================
        // 1. SETUP & MAZE LOGIC
        // ==========================================
        const canvas = document.getElementById("glCanvas");
        const gl = canvas.getContext("webgl2");
        const uiPos = document.getElementById("pos");

        if (!gl) alert("WebGL2 not supported");

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        window.addEventListener("resize", resize);
        resize();

        function hash(x, y) {
            let n = Math.sin(x * 12.9898 + y * 78.233) * 43758.5453;
            return n - Math.floor(n);
        }

        function isWall(gx, gy) {
            const xEven = (gx % 2 === 0);
            const yEven = (gy % 2 === 0);
            if (xEven && yEven) return true;
            if (!xEven && !yEven) return false;
            if (!xEven && yEven) return (hash(gx, gy + 1) >= 0.5);
            if (xEven && !yEven) return (hash(gx + 1, gy) < 0.5);
            return false;
        }

        // ==========================================
        // 2. SHADERS
        // ==========================================
        const vsSource = `#version 300 es
layout(location = 0) in vec3 aPos;
layout(location = 1) in vec3 aNormal;
layout(location = 2) in vec3 aInstancePos; 

uniform mat4 uModel; 
uniform mat4 uView;
uniform mat4 uProjection;
uniform bool uIsInstanced; 

out vec3 vNormal;

void main() {
    vec3 worldPos;
    if (uIsInstanced) {
        worldPos = aPos + aInstancePos;
    } else {
        worldPos = vec3(uModel * vec4(aPos, 1.0));
    }
    
    vNormal = aNormal;
    gl_Position = uProjection * uView * vec4(worldPos, 1.0);
}`;

        const fsSource = `#version 300 es
precision mediump float;

in vec3 vNormal;
uniform vec4 uColor;
uniform vec3 uLightDir;

out vec4 FragColor;

void main() {
    vec3 norm = normalize(vNormal);
    float diff = max(dot(norm, normalize(uLightDir)), 0.2); 
    
    vec3 finalColor = uColor.rgb;
    if (uColor.a > 0.8) {
        finalColor = finalColor * diff;
    }

    FragColor = vec4(finalColor, uColor.a);
}`;

        function createProgram(vsSrc, fsSrc) {
            const vs = gl.createShader(gl.VERTEX_SHADER); gl.shaderSource(vs, vsSrc); gl.compileShader(vs);
            const fs = gl.createShader(gl.FRAGMENT_SHADER); gl.shaderSource(fs, fsSrc); gl.compileShader(fs);
            const p = gl.createProgram(); gl.attachShader(p, vs); gl.attachShader(p, fs); gl.linkProgram(p);
            return p;
        }
        const program = createProgram(vsSource, fsSource);

        // ==========================================
        // 3. GEOMETRY BUFFERS
        // ==========================================

        const cubeVerts = new Float32Array([
            // Top
            -0.5, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0.5, 0, 1, 0,
            -0.5, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0.5, 0, 1, 0, -0.5, 0.5, 0.5, 0, 1, 0,
            // Front
            -0.5, -0.5, 0.5, 0, 0, 1, 0.5, -0.5, 0.5, 0, 0, 1, 0.5, 0.5, 0.5, 0, 0, 1,
            -0.5, -0.5, 0.5, 0, 0, 1, 0.5, 0.5, 0.5, 0, 0, 1, -0.5, 0.5, 0.5, 0, 0, 1,
            // Right
            0.5, -0.5, 0.5, 1, 0, 0, 0.5, -0.5, -0.5, 1, 0, 0, 0.5, 0.5, -0.5, 1, 0, 0,
            0.5, -0.5, 0.5, 1, 0, 0, 0.5, 0.5, -0.5, 1, 0, 0, 0.5, 0.5, 0.5, 1, 0, 0,
            // Back
            -0.5, -0.5, -0.5, 0, 0, -1, -0.5, 0.5, -0.5, 0, 0, -1, 0.5, 0.5, -0.5, 0, 0, -1,
            -0.5, -0.5, -0.5, 0, 0, -1, 0.5, 0.5, -0.5, 0, 0, -1, 0.5, -0.5, -0.5, 0, 0, -1,
            // Left
            -0.5, -0.5, -0.5, -1, 0, 0, -0.5, -0.5, 0.5, -1, 0, 0, -0.5, 0.5, 0.5, -1, 0, 0,
            -0.5, -0.5, -0.5, -1, 0, 0, -0.5, 0.5, 0.5, -1, 0, 0, -0.5, 0.5, -0.5, -1, 0, 0,
        ]);
        const cubeVAO = gl.createVertexArray();
        gl.bindVertexArray(cubeVAO);
        const cubeVBO = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVBO);
        gl.bufferData(gl.ARRAY_BUFFER, cubeVerts, gl.STATIC_DRAW);
        gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 24, 0); gl.enableVertexAttribArray(0);
        gl.vertexAttribPointer(1, 3, gl.FLOAT, false, 24, 12); gl.enableVertexAttribArray(1);

        const instanceVBO = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, instanceVBO);
        gl.bufferData(gl.ARRAY_BUFFER, 0, gl.DYNAMIC_DRAW);
        gl.vertexAttribPointer(2, 3, gl.FLOAT, false, 12, 0);
        gl.enableVertexAttribArray(2);
        gl.vertexAttribDivisor(2, 1);
        gl.bindVertexArray(null);

        function createConeData() {
            let verts = [];
            verts.push(0, 0, 0, 0, 1, 0);
            const angleWidth = Math.PI / 3;
            const segments = 20;
            const radius = 3.0;

            for (let i = 0; i <= segments; i++) {
                let a = -angleWidth / 2 + (angleWidth * i / segments);
                let x = Math.sin(a) * radius;
                let z = -Math.cos(a) * radius;
                verts.push(x, 0, z, 0, 1, 0);
            }
            return new Float32Array(verts);
        }
        const coneVerts = createConeData();
        const coneVAO = gl.createVertexArray();
        gl.bindVertexArray(coneVAO);
        const coneVBO = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, coneVBO);
        gl.bufferData(gl.ARRAY_BUFFER, coneVerts, gl.STATIC_DRAW);
        gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 24, 0); gl.enableVertexAttribArray(0);
        gl.vertexAttribPointer(1, 3, gl.FLOAT, false, 24, 12); gl.enableVertexAttribArray(1);
        gl.bindVertexArray(null);

        // ==========================================
        // 4. GAME STATE
        // ==========================================
        // Standard JS Array [x, y, z] used instead of glMatrix.vec3
        let playerPos = [1.5, 0, 1.5];
        let playerAngle = 0;
        const keys = {};

        window.addEventListener("keydown", e => keys[e.code] = true);
        window.addEventListener("keyup", e => keys[e.code] = false);

        // ==========================================
        // 5. LOOP
        // ==========================================

        function updateAndRender() {
            // --- 1. Physics ---
            const moveSpeed = 0.05;
            const rotSpeed = 0.04;

            if (keys["KeyA"]) playerAngle += rotSpeed;
            if (keys["KeyD"]) playerAngle -= rotSpeed;

            const sinA = Math.sin(playerAngle);
            const cosA = Math.cos(playerAngle);

            let dx = 0;
            let dz = 0;

            if (keys["KeyW"]) {
                dx -= sinA * moveSpeed;
                dz -= cosA * moveSpeed;
            }
            if (keys["KeyS"]) {
                dx += sinA * moveSpeed;
                dz += cosA * moveSpeed;
            }

            if (dx !== 0 || dz !== 0) {
                let nextX = playerPos[0] + dx;
                let nextZ = playerPos[2] + dz;
                const radius = 0.3;

                const check = (x, z) => isWall(Math.floor(x), Math.floor(z));

                if (!check(nextX + radius, playerPos[2]) && !check(nextX - radius, playerPos[2])) {
                    playerPos[0] = nextX;
                }
                if (!check(playerPos[0], nextZ + radius) && !check(playerPos[0], nextZ - radius)) {
                    playerPos[2] = nextZ;
                }
            }

            uiPos.innerText = `${Math.floor(playerPos[0])}, ${Math.floor(playerPos[2])}`;

            // --- 2. Render Setup ---
            gl.clearColor(0.1, 0.1, 0.1, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            gl.enable(gl.DEPTH_TEST);
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

            gl.useProgram(program);

            // CAMERA
            const view = Mat4.create();
            const projection = Mat4.create();

            Mat4.lookAt(view,
                [playerPos[0], 15, playerPos[2] + 0.1], // Eye
                [playerPos[0], 0, playerPos[2]],        // Target
                [0, 1, 0]                               // Up Vector
            );

            Mat4.perspective(projection, 45 * Math.PI / 180, canvas.width / canvas.height, 0.1, 100.0);

            gl.uniformMatrix4fv(gl.getUniformLocation(program, "uView"), false, view);
            gl.uniformMatrix4fv(gl.getUniformLocation(program, "uProjection"), false, projection);
            gl.uniform3f(gl.getUniformLocation(program, "uLightDir"), 0.5, 1.0, 0.3);

            // --- 3. Draw Maze ---
            const visibleRadius = 24;
            const px = Math.floor(playerPos[0]);
            const pz = Math.floor(playerPos[2]);
            const instances = [];

            for (let x = px - visibleRadius; x <= px + visibleRadius; x++) {
                for (let z = pz - visibleRadius; z <= pz + visibleRadius; z++) {
                    if (isWall(x, z)) {
                        instances.push(x + 0.5, 0.5, z + 0.5);
                    }
                }
            }

            if (instances.length > 0) {
                gl.uniform1i(gl.getUniformLocation(program, "uIsInstanced"), true);
                gl.uniform4f(gl.getUniformLocation(program, "uColor"), 0.4, 0.4, 0.45, 1.0);

                gl.bindBuffer(gl.ARRAY_BUFFER, instanceVBO);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(instances), gl.DYNAMIC_DRAW);

                gl.bindVertexArray(cubeVAO);
                gl.drawArraysInstanced(gl.TRIANGLES, 0, 36, instances.length / 3);
            }

            // --- 4. Draw Player (Dot) ---
            gl.uniform1i(gl.getUniformLocation(program, "uIsInstanced"), false);

            const modelPlayer = Mat4.create();
            Mat4.translate(modelPlayer, modelPlayer, playerPos);
            const pulse = 1.0 + Math.sin(Date.now() / 200) * 0.2;
            Mat4.scale(modelPlayer, modelPlayer, [0.4 * pulse, 0.4 * pulse, 0.4 * pulse]);

            gl.uniformMatrix4fv(gl.getUniformLocation(program, "uModel"), false, modelPlayer);
            gl.uniform4f(gl.getUniformLocation(program, "uColor"), 0.0, 1.0, 0.8, 1.0);

            gl.bindVertexArray(cubeVAO);
            gl.drawArrays(gl.TRIANGLES, 0, 36);

            // --- 5. Draw View Cone ---
            gl.depthMask(false);

            const modelCone = Mat4.create();
            Mat4.translate(modelCone, modelCone, [playerPos[0], 0.05, playerPos[2]]);
            Mat4.rotateY(modelCone, modelCone, playerAngle);

            gl.uniformMatrix4fv(gl.getUniformLocation(program, "uModel"), false, modelCone);
            gl.uniform4f(gl.getUniformLocation(program, "uColor"), 0.0, 1.0, 0.8, 0.3);

            gl.bindVertexArray(coneVAO);
            gl.drawArrays(gl.TRIANGLE_FAN, 0, 22);

            gl.depthMask(true);

            requestAnimationFrame(updateAndRender);
        }

        // Initial Spawn check
        if (isWall(Math.floor(playerPos[0]), Math.floor(playerPos[2]))) {
            playerPos[0] += 1.0;
        }

        requestAnimationFrame(updateAndRender);

    </script>
</body>

</html>