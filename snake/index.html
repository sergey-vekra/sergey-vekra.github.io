<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Hydro Snake - Enhanced Visuals</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #001;
        }

        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
            touch-action: none;
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.9);
            font-family: 'Segoe UI', sans-serif;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.8);
            pointer-events: none;
            user-select: none;
            z-index: 10;
        }

        h1 {
            margin: 0;
            font-size: 24px;
            letter-spacing: 1px;
        }

        p {
            margin: 5px 0 0 0;
            font-size: 14px;
            opacity: 0.7;
        }
    </style>
</head>

<body>
    <div id="ui">
        <h1 id="score">Score: 0</h1>
        <p>Visuals Upgraded: Scales, Wet Lighting, 3D Apple</p>
    </div>
    <canvas id="glcanvas"></canvas>

    <script>
        // ==================================================================================
        //  ⚙️ CONFIGURATION ⚙️
        // ==================================================================================
        const CONFIG = {
            GAME: {
                SPEED: 0.008,
                START_LENGTH: 8,
                SEGMENT_DIST: 0.04, // Closer segments for better fusion
                TURN_SENSITIVITY: 30,
                MAX_SNAKE_RENDER: 60,
            },

            WATER: {
                COLOR_DEEP: [0.0, 0.05, 0.15],
                COLOR_SHALLOW: [0.0, 0.35, 0.55],
                WAVE_SPEED: 1.2,
                NOISE_SCALE: 4.0,
                SPECULAR_POWER: 60.0,
                SPECULAR_INTENSITY: 0.7,
                REFRACTION_STR: 0.04,
            },

            SNAKE_VISUALS: {
                RADIUS: 0.025,
                SMOOTH_BLEND: 0.03, // How much segments melt into each other (Metaballs)
                COLOR_BODY_BASE: [0.1, 0.6, 0.3], // Base green
                COLOR_BODY_SCALES: [0.6, 0.9, 0.2], // Lighter scale highlights
                COLOR_BELLY: [0.8, 0.9, 0.5], // Light belly color
                COLOR_EYES: [1.0, 0.6, 0.0], // Glowing Orange eyes
                SCALE_DENSITY: 80.0,
            },

            APPLE: {
                RADIUS: 0.032,
                COLOR: [0.85, 0.05, 0.1],
                STEM_COLOR: [0.4, 0.2, 0.1],
                BOB_SPEED: 3.0,
                BOB_HEIGHT: 0.005,
            },

            WAKE: {
                HEAD_PRESSURE_SIZE: 0.002,
                HEAD_PRESSURE_HEIGHT: 0.005,
                TRAIL_DROP_INTERVAL: 10,
                TRAIL_LIFESPAN: 1.2,
                TRAIL_MAX_COUNT: 10,
                RIPPLE_SPEED: 50.0,
                RIPPLE_HEIGHT: 0.015,
                RIPPLE_WIDTH: 0.015,
            }
        };

        const glFloat = (n) => Number.isInteger(n) ? n.toFixed(1) : n.toString();
        const glVec3 = (arr) => `vec3(${glFloat(arr[0])}, ${glFloat(arr[1])}, ${glFloat(arr[2])})`;

        const VERTEX_SOURCE = `
            attribute vec2 position;
            void main() { gl_Position = vec4(position, 0.0, 1.0); }
        `;

        const FRAGMENT_SOURCE = `
            precision mediump float;

            uniform vec2 u_resolution;
            uniform float u_time;
            
            #define MAX_SNAKE ${CONFIG.GAME.MAX_SNAKE_RENDER}
            uniform vec2 u_snake[MAX_SNAKE];
            uniform int u_snakeLen;
            
            uniform vec3 u_apple;
            uniform float u_appleSplash;

            #define MAX_RIPPLES ${CONFIG.WAKE.TRAIL_MAX_COUNT}
            uniform vec3 u_ripples[MAX_RIPPLES];
            uniform int u_rippleCount;

            // --- UTILS ---
            // Polynomial Smooth Min (Metaball function)
            float smin( float a, float b, float k ) {
                float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );
                return mix( b, a, h ) - k*h*(1.0-h);
            }

            vec2 hash( vec2 p ) {
                p = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );
                return -1.0 + 2.0*fract(sin(p)*43758.5453123);
            }

            float noise( in vec2 p ) {
                const float K1 = 0.366025404; const float K2 = 0.211324865; 
                vec2 i = floor( p + (p.x+p.y)*K1 );
                vec2 a = p - i + (i.x+i.y)*K2;
                float m = step(a.y,a.x); vec2 o = vec2(m,1.0-m);
                vec2 b = a - o + K2; vec2 c = a - 1.0 + 2.0*K2;
                vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );
                vec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));
                return dot( n, vec3(70.0) );
            }

            // --- SDF SHAPES ---
            float sdSegment( in vec2 p, in vec2 a, in vec2 b ) {
                vec2 pa = p-a, ba = b-a;
                float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );
                return length( pa - ba*h );
            }

            // --- WATER HEIGHT MAP ---
            float getHeight(vec2 p) {
                float height = 0.0;
                float t = u_time * ${glFloat(CONFIG.WATER.WAVE_SPEED)};
                
                // Base waves
                height += noise(p * ${glFloat(CONFIG.WATER.NOISE_SCALE)} + vec2(t*0.2, t*0.1)) * 0.04;
                height += noise(p * ${glFloat(CONFIG.WATER.NOISE_SCALE * 2.0)} - vec2(t*0.1, 0.0)) * 0.015;

                // Ripples
                for(int i=0; i<MAX_RIPPLES; i++){
                    if(i >= u_rippleCount) break;
                    vec3 r = u_ripples[i];
                    float d = length(p - r.xy);
                    float wave = sin(d * ${glFloat(CONFIG.WAKE.RIPPLE_SPEED)} - r.z * 25.0);
                    float radius = r.z * 0.5 + 0.05; 
                    float mask = exp(-pow(d - radius, 2.0) / 0.005);
                    float alpha = smoothstep(${glFloat(CONFIG.WAKE.TRAIL_LIFESPAN)}, 0.0, r.z);
                    height += wave * mask * ${glFloat(CONFIG.WAKE.RIPPLE_HEIGHT)} * alpha;
                }

                // Apple Splash
                if (u_appleSplash > 0.0) {
                    float dApple = length(p - u_apple.xy);
                    float wave = sin(dApple * 50.0 - u_appleSplash * 20.0);
                    float mask = exp(-pow(dApple - u_appleSplash, 2.0) / 0.02);
                    height += wave * mask * 0.15 * smoothstep(2.0, 0.0, u_appleSplash);
                }
                return height;
            }

            // --- RENDER OBJECTS ---
            // Returns vec4(color.rgb, alpha/mask)
            // Also modifies normal for lighting details
            void getObjects(vec2 p, vec2 uv, inout vec3 col, inout float height) {
                
                // 1. SNAKE RENDERING (Metaballs)
                float dSnake = 100.0;
                float radius = ${glFloat(CONFIG.SNAKE_VISUALS.RADIUS)};
                
                // Head vector (used for eyes)
                vec2 headPos = u_snake[0];
                vec2 headDir = normalize(u_snake[0] - u_snake[1]);
                vec2 headRight = vec2(-headDir.y, headDir.x);

                // Build the SDF field for the snake body
                for (int i = 0; i < MAX_SNAKE; i++) {
                    if (i >= u_snakeLen - 1) break;
                    
                    // Taper tail
                    float rad = radius;
                    if (i > u_snakeLen - 3) rad *= 0.6; 
                    if (i == 0) rad *= 1.15; // Bigger head

                    float seg = sdSegment(p, u_snake[i], u_snake[i+1]) - rad;
                    
                    if (i == 0) dSnake = seg;
                    else dSnake = smin(dSnake, seg, ${glFloat(CONFIG.SNAKE_VISUALS.SMOOTH_BLEND)});
                }

                if (dSnake < 0.0) {
                    // Snake Body Color
                    float pattern = sin(p.x * ${glFloat(CONFIG.SNAKE_VISUALS.SCALE_DENSITY)}) * sin(p.y * ${glFloat(CONFIG.SNAKE_VISUALS.SCALE_DENSITY)});
                    
                    // "Belly" check (dot product with normal estimation)
                    // Simple fake normal for coloring
                    vec3 fakeNorm = normalize(vec3(p - headPos, radius)); 
                    
                    vec3 skin = mix(${glVec3(CONFIG.SNAKE_VISUALS.COLOR_BODY_BASE)}, ${glVec3(CONFIG.SNAKE_VISUALS.COLOR_BODY_SCALES)}, smoothstep(-1.0, 1.0, pattern));
                    
                    // Eyes
                    vec2 localHead = p - headPos;
                    // Rotate to head space
                    float hx = dot(localHead, headRight);
                    float hy = dot(localHead, headDir);
                    
                    // Eye Coordinates
                    vec2 eyeL = vec2(-radius*0.5, radius*0.2);
                    vec2 eyeR = vec2(radius*0.5, radius*0.2);
                    
                    if (length(vec2(hx, hy) - eyeL) < radius*0.25 || length(vec2(hx, hy) - eyeR) < radius*0.25) {
                        skin = ${glVec3(CONFIG.SNAKE_VISUALS.COLOR_EYES)} * 1.5; // Glow
                    }

                    // Rim Lighting (Fresnel) for wet look
                    float fresnel = pow(1.0 + dSnake/radius, 3.0);
                    skin += vec3(0.3) * fresnel;

                    col = skin;
                    height += 0.02; // Raise snake above water
                }

                // 2. APPLE RENDERING
                vec2 applePos = u_apple.xy;
                // Bobbing animation
                float bob = sin(u_time * ${glFloat(CONFIG.APPLE.BOB_SPEED)}) * ${glFloat(CONFIG.APPLE.BOB_HEIGHT)};
                if (u_apple.z > 0.01) bob = 0.0; // Don't bob if falling
                
                // Perspective adjust for falling
                float scale = 1.0 + u_apple.z * 0.8;
                float appleRad = ${glFloat(CONFIG.APPLE.RADIUS)} * scale;

                // Simple sphere SDF
                float dApple = length(p - applePos) - appleRad;
                
                if (dApple < 0.0) {
                    // Local coords inside apple (-1 to 1)
                    vec2 localA = (p - applePos) / appleRad;
                    float z = sqrt(1.0 - dot(localA, localA)); // Sphere Z
                    
                    vec3 appleCol = ${glVec3(CONFIG.APPLE.COLOR)};
                    
                    // Dimple at top (rotate local coords to make dimple face up/light)
                    float dimple = smoothstep(0.1, 0.5, distance(localA, vec2(0.1, 0.1)));
                    appleCol *= (0.5 + 0.5*dimple);

                    // Stem
                    if (distance(localA, vec2(0.2, 0.2)) < 0.15) {
                         appleCol = ${glVec3(CONFIG.APPLE.STEM_COLOR)};
                    }

                    // Lighting on Apple
                    vec3 lightPos = vec3(-0.5, 0.5, 1.0);
                    vec3 norm = normalize(vec3(localA, z));
                    float diff = max(dot(norm, lightPos), 0.0);
                    float spec = pow(max(dot(norm, normalize(lightPos + vec3(0,0,1))), 0.0), 30.0);
                    
                    col = appleCol * (0.4 + 0.6*diff) + vec3(1.0)*spec*0.6;
                    
                    // Fake ambient occlusion at edges
                    col *= smoothstep(0.0, 0.1, -dApple);
                    height += 0.02 + u_apple.z;
                }
            }

            void main() {
                vec2 uv = gl_FragCoord.xy / u_resolution.xy;
                vec2 p = (2.0*gl_FragCoord.xy - u_resolution.xy) / u_resolution.y;

                // --- WATER RENDERING ---
                float e = 0.005;
                float h = getHeight(p);
                float hx = getHeight(p + vec2(e, 0.0));
                float hy = getHeight(p + vec2(0.0, e));
                vec3 normal = normalize(vec3(h - hx, h - hy, e * 2.0));

                vec3 lightDir = normalize(vec3(-0.5, 0.5, 0.8));
                vec3 viewDir = vec3(0.0, 0.0, 1.0);
                vec3 halfDir = normalize(lightDir + viewDir);
                
                // Specular Water
                float specular = pow(max(dot(normal, halfDir), 0.0), ${glFloat(CONFIG.WATER.SPECULAR_POWER)}); 
                
                // Refraction
                vec2 distortedUV = uv + normal.xy * ${glFloat(CONFIG.WATER.REFRACTION_STR)};
                float noiseVal = noise(distortedUV * 3.0 + u_time * 0.1);
                
                vec3 finalColor = mix(${glVec3(CONFIG.WATER.COLOR_DEEP)}, ${glVec3(CONFIG.WATER.COLOR_SHALLOW)}, noiseVal + h * 2.0);
                
                // Add Caustics
                float caustics = smoothstep(0.6, 1.0, noise(p*8.0 + u_time + normal.xy));
                finalColor += caustics * 0.08 * vec3(0.7, 0.9, 1.0);
                finalColor += vec3(1.0) * specular * ${glFloat(CONFIG.WATER.SPECULAR_INTENSITY)};

                // --- SHADOWS ---
                // Simple drop shadow for apple and snake
                vec2 shadowOffset = vec2(0.04, -0.04);
                
                // Apple Shadow
                float dAppleShadow = length((p - shadowOffset) - u_apple.xy) - ${glFloat(CONFIG.APPLE.RADIUS)};
                if (u_apple.z > 0.0) dAppleShadow -= u_apple.z * 0.5; // Shadow gets smaller as it goes up
                if (dAppleShadow < 0.0) finalColor *= 0.7;

                // Snake Shadow (approximated)
                float dSnakeShadow = 100.0;
                for (int i = 0; i < MAX_SNAKE; i++) {
                    if (i >= u_snakeLen - 1) break;
                    dSnakeShadow = min(dSnakeShadow, sdSegment(p - shadowOffset, u_snake[i], u_snake[i+1]));
                }
                if (dSnakeShadow < ${glFloat(CONFIG.SNAKE_VISUALS.RADIUS)}) finalColor *= 0.6;

                // --- DRAW OBJECTS ON TOP ---
                vec3 objCol = vec3(0.0);
                float objHeight = 0.0;
                
                // We run this to detect if we hit an object
                vec2 objP = p + normal.xy * 0.01; // Refract object position slightly
                
                // If apple is in air, don't refract it
                if (u_apple.z > 0.01) objP = p; 

                getObjects(objP, uv, objCol, objHeight);

                if (length(objCol) > 0.0) {
                    finalColor = objCol;
                }

                // Vignette
                float vig = 1.0 - length(uv - 0.5) * 0.5;
                finalColor *= vig;

                gl_FragColor = vec4(finalColor, 1.0);
            }
        `;

        // ==================================================================================
        //  ENGINE (UNCHANGED LOGIC, JUST PASSING DATA)
        // ==================================================================================
        const canvas = document.getElementById('glcanvas');
        const gl = canvas.getContext('webgl', { alpha: false, depth: false });
        const uiScore = document.getElementById('score');

        function resize() {
            const dpr = Math.min(window.devicePixelRatio || 1, 1.5);
            canvas.width = window.innerWidth * dpr;
            canvas.height = window.innerHeight * dpr;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        window.addEventListener('resize', resize);
        resize();

        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(shader));
            }
            return shader;
        }

        const program = gl.createProgram();
        gl.attachShader(program, createShader(gl, gl.VERTEX_SHADER, VERTEX_SOURCE));
        gl.attachShader(program, createShader(gl, gl.FRAGMENT_SHADER, FRAGMENT_SOURCE));
        gl.linkProgram(program);
        gl.useProgram(program);

        gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1]), gl.STATIC_DRAW);
        gl.enableVertexAttribArray(gl.getAttribLocation(program, "position"));
        gl.vertexAttribPointer(gl.getAttribLocation(program, "position"), 2, gl.FLOAT, false, 0, 0);

        const locs = {
            res: gl.getUniformLocation(program, "u_resolution"),
            time: gl.getUniformLocation(program, "u_time"),
            snake: gl.getUniformLocation(program, "u_snake"),
            snakeLen: gl.getUniformLocation(program, "u_snakeLen"),
            apple: gl.getUniformLocation(program, "u_apple"),
            appleSplash: gl.getUniformLocation(program, "u_appleSplash"),
            ripples: gl.getUniformLocation(program, "u_ripples"),
            rippleCount: gl.getUniformLocation(program, "u_rippleCount")
        };

        let snake = [];
        for (let i = 0; i < CONFIG.GAME.START_LENGTH; i++) snake.push({ x: 0, y: -i * CONFIG.GAME.SEGMENT_DIST });
        let dir = { x: 0, y: 1 };
        let inputQ = [];
        let score = 0;
        let apple = { x: 0, y: 0.5, z: 2.0, falling: true };
        let splashTimer = 0.0;
        let ripples = [];
        let rippleDropTimer = 0;

        function spawnApple() {
            const aspect = canvas.width / canvas.height;
            apple.x = (Math.random() * 2 - 1) * aspect * 0.8;
            apple.y = (Math.random() * 2 - 1) * 0.8;
            apple.z = 2.0;
            apple.falling = true;
            splashTimer = 0.0;
        }
        spawnApple();

        function handleInput(newDir) {
            const last = inputQ.length > 0 ? inputQ[inputQ.length - 1] : dir;
            if (newDir.x !== 0 && last.x === 0) inputQ.push(newDir);
            if (newDir.y !== 0 && last.y === 0) inputQ.push(newDir);
        }

        window.addEventListener('keydown', e => {
            if (e.key === "ArrowUp") handleInput({ x: 0, y: 1 });
            if (e.key === "ArrowDown") handleInput({ x: 0, y: -1 });
            if (e.key === "ArrowLeft") handleInput({ x: -1, y: 0 });
            if (e.key === "ArrowRight") handleInput({ x: 1, y: 0 });
        });

        let tx = 0, ty = 0;
        canvas.addEventListener('touchstart', e => { tx = e.changedTouches[0].screenX; ty = e.changedTouches[0].screenY; }, { passive: false });
        canvas.addEventListener('touchend', e => {
            let dx = e.changedTouches[0].screenX - tx;
            let dy = e.changedTouches[0].screenY - ty;
            if (Math.max(Math.abs(dx), Math.abs(dy)) > CONFIG.GAME.TURN_SENSITIVITY) {
                if (Math.abs(dx) > Math.abs(dy)) handleInput(dx > 0 ? { x: 1, y: 0 } : { x: -1, y: 0 });
                else handleInput(dy > 0 ? { x: 0, y: -1 } : { x: 0, y: 1 });
            }
        }, { passive: false });

        function loop(now) {
            let totalTime = now * 0.001;

            if (inputQ.length) dir = inputQ.shift();

            // Move Head
            let head = { x: snake[0].x + dir.x * CONFIG.GAME.SPEED, y: snake[0].y + dir.y * CONFIG.GAME.SPEED };
            const aspect = canvas.width / canvas.height;

            if (head.x > aspect) { snake.forEach(s => s.x -= 2 * aspect); head.x -= 2 * aspect; }
            if (head.x < -aspect) { snake.forEach(s => s.x += 2 * aspect); head.x += 2 * aspect; }
            if (head.y > 1.0) { snake.forEach(s => s.y -= 2.0); head.y -= 2.0; }
            if (head.y < -1.0) { snake.forEach(s => s.y += 2.0); head.y += 2.0; }

            // Ripples
            rippleDropTimer++;
            if (rippleDropTimer > CONFIG.WAKE.TRAIL_DROP_INTERVAL) {
                ripples.push({ x: head.x, y: head.y, age: 0.0 });
                rippleDropTimer = 0;
            }
            for (let i = ripples.length - 1; i >= 0; i--) {
                ripples[i].age += 0.016;
                if (ripples[i].age > CONFIG.WAKE.TRAIL_LIFESPAN) ripples.splice(i, 1);
            }
            if (ripples.length > CONFIG.WAKE.TRAIL_MAX_COUNT) ripples.shift();

            // Update Body
            let nextSnake = [head];
            for (let i = 1; i < snake.length; i++) {
                let prev = nextSnake[i - 1];
                let curr = snake[i];
                let dx = curr.x - prev.x; let dy = curr.y - prev.y;
                let d = Math.sqrt(dx * dx + dy * dy);
                if (d > CONFIG.GAME.SEGMENT_DIST) {
                    let r = (d - CONFIG.GAME.SEGMENT_DIST) / d;
                    curr.x -= dx * r; curr.y -= dy * r;
                }
                nextSnake.push(curr);
            }
            snake = nextSnake;

            // Apple
            if (apple.falling) {
                apple.z -= 0.05;
                if (apple.z <= 0) { apple.z = 0; apple.falling = false; splashTimer = 0.001; }
            } else {
                let dx = head.x - apple.x; let dy = head.y - apple.y;
                if (Math.sqrt(dx * dx + dy * dy) < 0.1) {
                    score++; uiScore.innerText = "Score: " + score;
                    snake.push({ ...snake[snake.length - 1] }); spawnApple();
                }
            }
            if (splashTimer > 0) { splashTimer += 0.015; if (splashTimer > 2.0) splashTimer = 0; }

            // Collision
            for (let i = 10; i < snake.length; i++) {
                let dx = head.x - snake[i].x; let dy = head.y - snake[i].y;
                if (Math.sqrt(dx * dx + dy * dy) < CONFIG.GAME.SEGMENT_DIST * 0.5) {
                    score = 0; uiScore.innerText = "Score: 0";
                    snake = [];
                    for (let k = 0; k < CONFIG.GAME.START_LENGTH; k++) snake.push({ x: 0, y: -k * CONFIG.GAME.SEGMENT_DIST });
                }
            }

            // Render
            let flatSnake = [];
            snake.forEach(s => flatSnake.push(s.x, s.y));
            while (flatSnake.length < CONFIG.GAME.MAX_SNAKE_RENDER * 2) flatSnake.push(0, 0);

            let flatRipples = [];
            ripples.forEach(r => flatRipples.push(r.x, r.y, r.age));
            while (flatRipples.length < CONFIG.WAKE.TRAIL_MAX_COUNT * 3) flatRipples.push(0, 0, 100.0);

            gl.uniform2fv(locs.res, [canvas.width, canvas.height]);
            gl.uniform1f(locs.time, totalTime);
            gl.uniform2fv(locs.snake, new Float32Array(flatSnake));
            gl.uniform1i(locs.snakeLen, snake.length);
            gl.uniform3fv(locs.ripples, new Float32Array(flatRipples));
            gl.uniform1i(locs.rippleCount, ripples.length);
            gl.uniform3f(locs.apple, apple.x, apple.y, apple.z);
            gl.uniform1f(locs.appleSplash, splashTimer);

            gl.drawArrays(gl.TRIANGLES, 0, 6);
            requestAnimationFrame(loop);
        }
        requestAnimationFrame(loop);
    </script>
</body>

</html>