<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Hydro Snake Mobile Optimized</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #001;
        }

        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
            touch-action: none;
            /* Prevents scrolling */
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: rgba(200, 240, 255, 0.9);
            font-family: 'Segoe UI', sans-serif;
            text-shadow: 0 2px 5px rgba(0, 0, 0, 1.0);
            pointer-events: none;
            z-index: 10;
            user-select: none;
        }

        h1 {
            margin: 0;
            font-size: 28px;
            letter-spacing: 2px;
        }

        p {
            margin: 5px 0 0 0;
            font-size: 14px;
            opacity: 0.7;
        }
    </style>
</head>

<body>
    <div id="ui">
        <h1 id="score">Score: 0</h1>
        <p>Swipe to swim</p>
    </div>
    <canvas id="glcanvas"></canvas>

    <!-- VERTEX SHADER -->
    <script id="vs" type="x-shader/x-vertex">
        attribute vec2 position;
        void main() {
            gl_Position = vec4(position, 0.0, 1.0);
        }
    </script>

    <!-- FRAGMENT SHADER -->
    <script id="fs" type="x-shader/x-fragment">
        precision mediump float; // Use medium precision for mobile performance

        uniform vec2 u_resolution;
        uniform float u_time;
        
        #define MAX_SNAKE 60
        uniform vec2 u_snake[MAX_SNAKE];
        uniform int u_snakeLen;
        
        uniform vec3 u_apple;
        uniform float u_appleSplash;

        // --- MATH HELPERS ---
        vec2 hash( vec2 p ) {
            p = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );
            return -1.0 + 2.0*fract(sin(p)*43758.5453123);
        }

        float noise( in vec2 p ) {
            const float K1 = 0.366025404; 
            const float K2 = 0.211324865; 
            vec2 i = floor( p + (p.x+p.y)*K1 );
            vec2 a = p - i + (i.x+i.y)*K2;
            float m = step(a.y,a.x); 
            vec2 o = vec2(m,1.0-m);
            vec2 b = a - o + K2;
            vec2 c = a - 1.0 + 2.0*K2;
            vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );
            vec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));
            return dot( n, vec3(70.0) );
        }

        float sdSegment( in vec2 p, in vec2 a, in vec2 b ) {
            vec2 pa = p-a, ba = b-a;
            float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );
            return length( pa - ba*h );
        }

        // --- OPTIMIZED PHYSICS & HEIGHT MAP ---
        float getHeight(vec2 p) {
            float height = 0.0;
            float t = u_time * 1.5;

            // 1. Ambient Ocean Noise (Reduced complexity)
            // Using slightly larger scales to reduce visual noise
            height += noise(p * 3.0 + vec2(t*0.2, t*0.1)) * 0.04;
            height += noise(p * 7.0 - vec2(t*0.1, 0.0)) * 0.02;

            // 2. Snake Interaction (OPTIMIZED)
            // Instead of checking the whole body, we only check the HEAD for the wake.
            // This saves ~60 iterations per pixel call.
            float dHead = length(p - u_snake[0]);
            
            // "Bow Wave" at the head
            float headWake = smoothstep(0.15, 0.0, dHead);
            height += headWake * 0.1 * sin(dHead * 20.0 - u_time * 10.0);

            // 3. Apple Splash Interaction
            if (u_appleSplash > 0.0) {
                float dApple = length(p - u_apple.xy);
                float wave = sin(dApple * 30.0 - u_appleSplash * 20.0);
                float expandRadius = u_appleSplash * 1.0; 
                float mask = exp(-pow(dApple - expandRadius, 2.0) / 0.02);
                float dampen = smoothstep(2.0, 0.0, u_appleSplash);
                height += wave * mask * 0.15 * dampen;
            }

            return height;
        }

        void main() {
            vec2 uv = gl_FragCoord.xy / u_resolution.xy;
            // Aspect corrected coordinates
            vec2 p = (2.0*gl_FragCoord.xy - u_resolution.xy) / u_resolution.y;

            // --- NORMALS ---
            // We calculate height 3 times to get the slope (normal)
            float e = 0.005; // Slightly coarser epsilon for smoother look
            float h = getHeight(p);
            float hx = getHeight(p + vec2(e, 0.0));
            float hy = getHeight(p + vec2(0.0, e));
            vec3 normal = normalize(vec3(h - hx, h - hy, e * 2.0));

            // --- LIGHTING ---
            vec3 lightDir = normalize(vec3(-0.5, 0.5, 0.8));
            vec3 viewDir = vec3(0.0, 0.0, 1.0);
            
            vec3 halfDir = normalize(lightDir + viewDir);
            float specAngle = max(dot(normal, halfDir), 0.0);
            float specular = pow(specAngle, 80.0); 
            
            // Refraction
            vec2 distortedUV = uv + normal.xy * 0.03;
            
            // Water Color
            vec3 deepCol = vec3(0.0, 0.05, 0.2);
            vec3 shallowCol = vec3(0.0, 0.4, 0.6);
            
            // Simpler noise for color mixing to save performance
            float noiseVal = noise(distortedUV * 3.0 + u_time * 0.1);
            vec3 waterCol = mix(deepCol, shallowCol, noiseVal + h * 1.5);

            // --- DRAW OBJECTS ---
            // Refract coordinate
            vec2 pDis = p + normal.xy * 0.02; 

            vec3 objectCol = vec3(0.0);
            float objectMask = 0.0;

            // 1. Apple
            vec2 applePos = u_apple.xy;
            float appleH = u_apple.z;
            float scale = 1.0 + appleH * 0.5;
            
            // Determine if we use refracted or real coordinates based on apple height
            vec2 checkPos = (appleH > 0.01) ? p : pDis;
            float rad = (appleH > 0.01) ? 0.035 * scale : 0.035;

            float dApple = length(checkPos - applePos) - rad;

            if (dApple < 0.0) {
                vec3 appleColor = vec3(0.9, 0.1, 0.1);
                float appleLight = dot(normalize(vec3(checkPos-applePos, 0.5)), lightDir);
                objectCol = appleColor * (0.6 + 0.4*appleLight);
                objectMask = 1.0;
            }

            // 2. Snake Body
            // We must loop here to draw the shape, but this is only done ONCE per pixel,
            // unlike getHeight which is called 3 times per pixel.
            float dSnake = 100.0;
            
            // Bounding box optimization: 
            // Only check snake if pixel is roughly near the center or we know where the snake is.
            // (Skipped for code simplicity, but pure iteration is fast enough for <60 items once)
            for (int i = 0; i < MAX_SNAKE; i++) {
                if (i >= u_snakeLen - 1) break;
                float seg = sdSegment(pDis, u_snake[i], u_snake[i+1]);
                dSnake = min(dSnake, seg);
            }
            
            if (dSnake < 0.035) {
                float pat = 0.5 + 0.5 * sin(pDis.x * 50.0 + pDis.y * 50.0);
                vec3 skinCol = mix(vec3(0.1, 0.6, 0.2), vec3(0.3, 0.8, 0.1), pat);
                
                // Eyes (Head is index 0)
                if (length(pDis - u_snake[0]) < 0.035) {
                     vec2 dir = normalize(u_snake[0] - u_snake[1]);
                     vec2 side = vec2(-dir.y, dir.x);
                     vec2 eyeL = u_snake[0] + side * 0.015 - dir * 0.01;
                     vec2 eyeR = u_snake[0] - side * 0.015 - dir * 0.01;
                     if (length(pDis - eyeL) < 0.008 || length(pDis - eyeR) < 0.008) {
                         skinCol = vec3(1.0, 1.0, 0.0);
                     }
                }
                objectCol = skinCol;
                objectMask = 1.0;
            }
            
            // --- COMPOSITE ---
            vec3 finalColor = waterCol;
            if (objectMask > 0.0) {
                float fog = 0.2; 
                if (u_apple.z > 0.0 && dApple < 0.0) fog = 0.0;
                finalColor = mix(objectCol, waterCol, fog);
            }

            finalColor += vec3(1.0) * specular * 0.8;
            
            // Simplified Caustics
            // Only calculate caustics near center or if performance allows. 
            // We keep it simple here.
            float caustics = smoothstep(0.7, 1.0, noise(p*8.0 + u_time + normal.xy));
            finalColor += caustics * 0.05 * vec3(0.8, 0.9, 1.0);

            // Shadow
            if (u_apple.z > 0.1) {
                float dShadow = length(pDis - (u_apple.xy + vec2(0.05, -0.05))) - 0.02;
                if (dShadow < 0.0) finalColor *= 0.6;
            }

            gl_FragColor = vec4(finalColor, 1.0);
        }
    </script>

    <script>
        const canvas = document.getElementById('glcanvas');
        const gl = canvas.getContext('webgl', { alpha: false, depth: false }); // Optimization hints
        const uiScore = document.getElementById('score');

        // OPTIMIZATION: Handle resolution
        // Mobile screens have high DPR (2x, 3x). Rendering full resolution kills performance.
        // We cap DPR to 1.0 or 1.5 max for performance.
        function resize() {
            // Force lower resolution on high-DPI screens
            const dpr = Math.min(window.devicePixelRatio || 1, 1.5);
            const displayWidth = Math.floor(window.innerWidth * dpr);
            const displayHeight = Math.floor(window.innerHeight * dpr);

            if (canvas.width !== displayWidth || canvas.height !== displayHeight) {
                canvas.width = displayWidth;
                canvas.height = displayHeight;
            }
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        window.addEventListener('resize', resize);
        resize();

        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(shader));
                return null;
            }
            return shader;
        }

        const program = gl.createProgram();
        gl.attachShader(program, createShader(gl, gl.VERTEX_SHADER, document.getElementById('vs').text));
        gl.attachShader(program, createShader(gl, gl.FRAGMENT_SHADER, document.getElementById('fs').text));
        gl.linkProgram(program);
        gl.useProgram(program);

        gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1]), gl.STATIC_DRAW);
        const posLoc = gl.getAttribLocation(program, "position");
        gl.enableVertexAttribArray(posLoc);
        gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

        const locs = {
            res: gl.getUniformLocation(program, "u_resolution"),
            time: gl.getUniformLocation(program, "u_time"),
            snake: gl.getUniformLocation(program, "u_snake"),
            snakeLen: gl.getUniformLocation(program, "u_snakeLen"),
            apple: gl.getUniformLocation(program, "u_apple"),
            appleSplash: gl.getUniformLocation(program, "u_appleSplash")
        };

        let snake = [];
        for (let i = 0; i < 15; i++) snake.push({ x: 0, y: -i * 0.04 });
        let dir = { x: 0, y: 1 };
        let inputQ = [];
        let score = 0;
        let speed = 0.007;

        let apple = { x: 0, y: 0.5, z: 2.0, falling: true };
        let splashTimer = 0.0;

        // Prevent time from getting too large (Micro-waves fix)
        let totalTime = 0;

        function spawnApple() {
            // Need to account for aspect ratio in game logic
            const aspect = canvas.width / canvas.height;
            apple.x = (Math.random() * 2 - 1) * aspect * 0.8;
            apple.y = (Math.random() * 2 - 1) * 0.8;
            apple.z = 2.0;
            apple.falling = true;
            splashTimer = 0.0;
        }
        spawnApple();

        function handleInput(newDir) {
            const last = inputQ.length > 0 ? inputQ[inputQ.length - 1] : dir;
            if (newDir.x !== 0 && last.x === 0) inputQ.push(newDir);
            if (newDir.y !== 0 && last.y === 0) inputQ.push(newDir);
        }

        window.addEventListener('keydown', e => {
            if (e.key === "ArrowUp") handleInput({ x: 0, y: 1 });
            if (e.key === "ArrowDown") handleInput({ x: 0, y: -1 });
            if (e.key === "ArrowLeft") handleInput({ x: -1, y: 0 });
            if (e.key === "ArrowRight") handleInput({ x: 1, y: 0 });
        });

        // Touch Logic
        let touchStartX = 0;
        let touchStartY = 0;
        canvas.addEventListener('touchstart', e => {
            touchStartX = e.changedTouches[0].screenX;
            touchStartY = e.changedTouches[0].screenY;
        }, { passive: false });

        canvas.addEventListener('touchend', e => {
            let touchEndX = e.changedTouches[0].screenX;
            let touchEndY = e.changedTouches[0].screenY;

            let dx = touchEndX - touchStartX;
            let dy = touchEndY - touchStartY;

            if (Math.max(Math.abs(dx), Math.abs(dy)) < 30) return;

            if (Math.abs(dx) > Math.abs(dy)) {
                if (dx > 0) handleInput({ x: 1, y: 0 });
                else handleInput({ x: -1, y: 0 });
            } else {
                if (dy > 0) handleInput({ x: 0, y: -1 });
                else handleInput({ x: 0, y: 1 });
            }
        }, { passive: false });

        function loop(now) {
            // Precision Fix: Keep time roughly periodic or small
            // We use 'now' from requestAnimationFrame, but send a modulo'd time to shader
            // to prevent float precision artifacts ("micro waves")
            totalTime = now * 0.001;
            // 10000 is enough for no visible seam, small enough for mediump precision
            let shaderTime = totalTime % 10000.0;

            if (inputQ.length) dir = inputQ.shift();

            let head = { x: snake[0].x + dir.x * speed, y: snake[0].y + dir.y * speed };

            const aspect = canvas.width / canvas.height;
            // Wrap logic
            if (head.x > aspect) { snake.forEach(s => s.x -= 2 * aspect); head.x -= 2 * aspect; }
            if (head.x < -aspect) { snake.forEach(s => s.x += 2 * aspect); head.x += 2 * aspect; }
            if (head.y > 1.0) { snake.forEach(s => s.y -= 2.0); head.y -= 2.0; }
            if (head.y < -1.0) { snake.forEach(s => s.y += 2.0); head.y += 2.0; }

            // Move body
            let nextSnake = [head];
            for (let i = 1; i < snake.length; i++) {
                let prev = nextSnake[i - 1];
                let curr = snake[i];
                let dx = curr.x - prev.x;
                let dy = curr.y - prev.y;
                let d = Math.sqrt(dx * dx + dy * dy);
                const segLen = 0.04;
                if (d > segLen) {
                    let r = (d - segLen) / d;
                    curr.x -= dx * r;
                    curr.y -= dy * r;
                }
                nextSnake.push(curr);
            }
            snake = nextSnake;

            // Apple logic
            if (apple.falling) {
                apple.z -= 0.05;
                if (apple.z <= 0) {
                    apple.z = 0;
                    apple.falling = false;
                    splashTimer = 0.001;
                }
            } else {
                let dx = head.x - apple.x;
                let dy = head.y - apple.y;
                if (Math.sqrt(dx * dx + dy * dy) < 0.1) {
                    score++;
                    uiScore.innerText = "Score: " + score;
                    snake.push({ ...snake[snake.length - 1] });
                    spawnApple();
                }
            }

            if (splashTimer > 0) {
                splashTimer += 0.015;
                if (splashTimer > 2.0) splashTimer = 0;
            }

            // Collision
            for (let i = 10; i < snake.length; i++) {
                let dx = head.x - snake[i].x;
                let dy = head.y - snake[i].y;
                if (Math.sqrt(dx * dx + dy * dy) < 0.02) {
                    score = 0;
                    uiScore.innerText = "Score: 0";
                    snake = snake.slice(0, 15);
                }
            }

            // Render
            let flatSnake = [];
            for (let i = 0; i < snake.length; i++) {
                flatSnake.push(snake[i].x);
                flatSnake.push(snake[i].y);
            }
            // Fill array to avoid gl errors
            while (flatSnake.length < 120) flatSnake.push(0, 0);

            gl.uniform2fv(locs.res, [canvas.width, canvas.height]);
            gl.uniform1f(locs.time, shaderTime);
            gl.uniform2fv(locs.snake, new Float32Array(flatSnake));
            gl.uniform1i(locs.snakeLen, snake.length);
            gl.uniform3f(locs.apple, apple.x, apple.y, apple.z);
            gl.uniform1f(locs.appleSplash, splashTimer > 0 ? splashTimer : 0.0);

            gl.drawArrays(gl.TRIANGLES, 0, 6);
            requestAnimationFrame(loop);
        }
        requestAnimationFrame(loop);
    </script>
</body>

</html>