<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Hydro Snake - Configurable Lighting</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000510;
        }

        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
            touch-action: none;
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.9);
            font-family: 'Segoe UI', sans-serif;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.8);
            pointer-events: none;
            user-select: none;
            z-index: 10;
        }

        h1 {
            margin: 0;
            font-size: 24px;
            letter-spacing: 1px;
        }

        p {
            margin: 5px 0 0 0;
            font-size: 14px;
            opacity: 0.7;
        }

        .hint {
            font-size: 11px;
            opacity: 0.5;
            margin-top: 5px;
        }
    </style>
</head>

<body>
    <div id="ui">
        <h1 id="score">Score: 0</h1>
        <p>Configurable Luminance</p>
        <p class="hint">Edit CONFIG object in source to tweak lighting</p>
    </div>
    <canvas id="glcanvas"></canvas>

    <script>
        // ==================================================================================
        //  ⚙️ EXPANDED CONFIGURATION ⚙️
        // ==================================================================================
        const CONFIG = {
            GAME: {
                SPEED: 0.008,
                START_LENGTH: 8,
                SEGMENT_DIST: 0.04,
                TURN_SENSITIVITY: 30,
                MAX_SNAKE_RENDER: 60,
            },

            WATER: {
                COLOR_DEEP: [0.0, 0.02, 0.1],      // Darker deep water for contrast
                COLOR_SHALLOW: [0.0, 0.25, 0.45], // Teal shallow water
                WAVE_SPEED: 1.2,
                NOISE_SCALE: 4.0,
                SPECULAR_POWER: 60.0,
                SPECULAR_INTENSITY: 0.5,
                REFRACTION_STR: 0.04,
            },

            // New section specifically for the glowing food
            APPLE: {
                RADIUS: 0.030,
                // Neon Red/Orange (Values > 1.0 create bloom artifacts)
                COLOR: [2.5, 0.4, 0.1],

                // Visualization of the object itself
                CORE_BRIGHTNESS: 2.0,    // How bright the center of the apple is
                EDGE_SOFTNESS: 0.2,      // 0.0 = Hard edge, 1.0 = Fuzzy ball of light

                // Animation
                BOB_SPEED: 3.0,
                BOB_HEIGHT: 0.5,
            },

            // New section to control how the light affects the scene
            LIGHTING: {
                // Controls how the light falls off with distance
                // Higher = Light dies faster (smaller pool of light)
                // Lower = Light travels further
                FALLOFF_STEEPNESS: 100.0,

                // How strong the light reflects on the water ripples
                WATER_REFLECTION_STR: 0.2,

                // How much the snake's body lights up when near the food
                SNAKE_ILLUMINATION_STR: 1.2,
            },

            SNAKE_VISUALS: {
                RADIUS: 0.025,
                SMOOTH_BLEND: 0.035,
                COLOR_BODY_BASE: [0.05, 0.2, 0.1],   // Very dark base to pop against light
                COLOR_BODY_SCALES: [0.4, 0.8, 0.3],  // Scale color
                COLOR_EYES: [1.0, 0.9, 0.2],         // Bright eyes
                SCALE_DENSITY_X: 3.0,
                SCALE_DENSITY_Y: 20.0,
            },

            WAKE: {
                TRAIL_DROP_INTERVAL: 10,
                TRAIL_LIFESPAN: 1.2,
                TRAIL_MAX_COUNT: 10,
                RIPPLE_SPEED: 50.0,
                RIPPLE_HEIGHT: 0.015,
            }
        };

        const glFloat = (n) => Number.isInteger(n) ? n.toFixed(1) : n.toString();
        const glVec3 = (arr) => `vec3(${glFloat(arr[0])}, ${glFloat(arr[1])}, ${glFloat(arr[2])})`;

        const VERTEX_SOURCE = `
            attribute vec2 position;
            void main() { gl_Position = vec4(position, 0.0, 1.0); }
        `;

        const FRAGMENT_SOURCE = `
            precision mediump float;

            uniform vec2 u_resolution;
            uniform float u_time;
            
            #define MAX_SNAKE ${CONFIG.GAME.MAX_SNAKE_RENDER}
            uniform vec2 u_snake[MAX_SNAKE];
            uniform int u_snakeLen;
            
            uniform vec3 u_apple;
            uniform float u_appleSplash;

            #define MAX_RIPPLES ${CONFIG.WAKE.TRAIL_MAX_COUNT}
            uniform vec3 u_ripples[MAX_RIPPLES];
            uniform int u_rippleCount;

            // --- UTILS ---
            float smin( float a, float b, float k ) {
                float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );
                return mix( b, a, h ) - k*h*(1.0-h);
            }

            vec2 hash( vec2 p ) {
                p = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );
                return -1.0 + 2.0*fract(sin(p)*43758.5453123);
            }

            float noise( in vec2 p ) {
                const float K1 = 0.366025404; const float K2 = 0.211324865; 
                vec2 i = floor( p + (p.x+p.y)*K1 );
                vec2 a = p - i + (i.x+i.y)*K2;
                float m = step(a.y,a.x); vec2 o = vec2(m,1.0-m);
                vec2 b = a - o + K2; vec2 c = a - 1.0 + 2.0*K2;
                vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );
                vec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));
                return dot( n, vec3(70.0) );
            }

            // --- WATER HEIGHT MAP ---
            float getHeight(vec2 p) {
                float height = 0.0;
                float t = u_time * ${glFloat(CONFIG.WATER.WAVE_SPEED)};
                
                // Base waves
                height += noise(p * ${glFloat(CONFIG.WATER.NOISE_SCALE)} + vec2(t*0.2, t*0.1)) * 0.04;
                height += noise(p * ${glFloat(CONFIG.WATER.NOISE_SCALE * 2.0)} - vec2(t*0.1, 0.0)) * 0.015;

                // Ripples
                for(int i=0; i<MAX_RIPPLES; i++){
                    if(i >= u_rippleCount) break;
                    vec3 r = u_ripples[i];
                    float d = length(p - r.xy);
                    float wave = sin(d * ${glFloat(CONFIG.WAKE.RIPPLE_SPEED)} - r.z * 25.0);
                    float radius = r.z * 0.5 + 0.05; 
                    float mask = exp(-pow(d - radius, 2.0) / 0.005);
                    float alpha = smoothstep(${glFloat(CONFIG.WAKE.TRAIL_LIFESPAN)}, 0.0, r.z);
                    height += wave * mask * ${glFloat(CONFIG.WAKE.RIPPLE_HEIGHT)} * alpha;
                }

                // Apple Splash
                if (u_appleSplash > 0.0) {
                    float dApple = length(p - u_apple.xy);
                    float wave = sin(dApple * 50.0 - u_appleSplash * 20.0);
                    float mask = exp(-pow(dApple - u_appleSplash, 2.0) / 0.02);
                    height += wave * mask * 0.15 * smoothstep(2.0, 0.0, u_appleSplash);
                }
                return height;
            }

            // --- RENDER OBJECTS ---
            void getObjects(vec2 p, vec2 uv, inout vec3 col, inout float height) {
                
                // 1. SNAKE RENDERING
                float dSnake = 100.0;
                float radius = ${glFloat(CONFIG.SNAKE_VISUALS.RADIUS)};
                
                float accumPattern = 0.0;
                float accumWeight = 0.0;
                
                vec2 headPos = u_snake[0];
                vec2 headDir = normalize(u_snake[0] - u_snake[1]);
                vec2 headRight = vec2(-headDir.y, headDir.x);

                for (int i = 0; i < MAX_SNAKE; i++) {
                    if (i >= u_snakeLen - 1) break;
                    vec2 a = u_snake[i];
                    vec2 b = u_snake[i+1];
                    vec2 pa = p - a, ba = b - a;
                    float h = clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.0);
                    float segDist = length(pa - ba*h);
                    
                    float rad = radius;
                    if (i > u_snakeLen - 3) rad *= 0.6; 
                    if (i == 0) rad *= 1.15; 

                    float dSeg = segDist - rad;
                    if (i == 0) dSnake = dSeg;
                    else dSnake = smin(dSnake, dSeg, ${glFloat(CONFIG.SNAKE_VISUALS.SMOOTH_BLEND)});

                    if (segDist < radius * 2.0) {
                        float bodyPos = float(i) + h; 
                        float scalePat = sin(bodyPos * ${glFloat(CONFIG.SNAKE_VISUALS.SCALE_DENSITY_X)}) * 
                                         sin(uv.x * ${glFloat(CONFIG.SNAKE_VISUALS.SCALE_DENSITY_Y)} + bodyPos);
                        float w = 1.0 / (segDist * segDist + 0.0001);
                        accumPattern += scalePat * w;
                        accumWeight += w;
                    }
                }

                if (dSnake < 0.0) {
                    float finalPattern = (accumWeight > 0.0) ? accumPattern / accumWeight : 0.0;
                    vec3 skin = mix(${glVec3(CONFIG.SNAKE_VISUALS.COLOR_BODY_BASE)}, ${glVec3(CONFIG.SNAKE_VISUALS.COLOR_BODY_SCALES)}, smoothstep(-0.8, 0.8, finalPattern));
                    
                    // Eyes
                    vec2 localHead = p - headPos;
                    float hx = dot(localHead, headRight);
                    float hy = dot(localHead, headDir);
                    if (length(vec2(hx, hy) - vec2(-radius*0.5, radius*0.2)) < radius*0.25 || 
                        length(vec2(hx, hy) - vec2(radius*0.5, radius*0.2)) < radius*0.25) {
                        skin = ${glVec3(CONFIG.SNAKE_VISUALS.COLOR_EYES)} * 2.0;
                    }

                    // Ambient Lighting
                    float fresnel = pow(1.0 + dSnake/radius, 3.0);
                    skin += vec3(0.4) * fresnel;

                    // --- SNAKE LIGHT RECEPTION ---
                    float dToLight = length(p - u_apple.xy);
                    vec3 lightColor = ${glVec3(CONFIG.APPLE.COLOR)};
                    // Configurable Falloff
                    float falloff = 1.0 / (1.0 + dToLight * dToLight * ${glFloat(CONFIG.LIGHTING.FALLOFF_STEEPNESS)});
                    float verticalAtten = 1.0 / (1.0 + u_apple.z * 5.0);
                    
                    skin += lightColor * falloff * verticalAtten * ${glFloat(CONFIG.LIGHTING.SNAKE_ILLUMINATION_STR)};

                    col = skin;
                    height += 0.02; 
                }

                // 2. APPLE RENDERING (Luminance Object)
                vec2 applePos = u_apple.xy;
                // Bobbing cancels if falling
                float bob = sin(u_time * ${glFloat(CONFIG.APPLE.BOB_SPEED)}) * ${glFloat(CONFIG.APPLE.BOB_HEIGHT)};
                if (u_apple.z > 0.01) bob = 0.0; 
                
                float scale = 1.0 + u_apple.z * 0.8;
                float appleRad = ${glFloat(CONFIG.APPLE.RADIUS)} * scale;

                float dApple = length(p - applePos) - appleRad;
                
                if (dApple < 0.0) {
                    // Configurable Core and Softness
                    float edge = smoothstep(0.0, -appleRad * ${glFloat(CONFIG.APPLE.EDGE_SOFTNESS)}, dApple);
                    vec3 appleCol = ${glVec3(CONFIG.APPLE.COLOR)};
                    col = appleCol * (${glFloat(CONFIG.APPLE.CORE_BRIGHTNESS)} * edge);
                    height += 0.02 + u_apple.z;
                }
            }

            void main() {
                vec2 uv = gl_FragCoord.xy / u_resolution.xy;
                vec2 p = (2.0*gl_FragCoord.xy - u_resolution.xy) / u_resolution.y;

                // Water Normal Calc
                float e = 0.005;
                float h = getHeight(p);
                float hx = getHeight(p + vec2(e, 0.0));
                float hy = getHeight(p + vec2(0.0, e));
                vec3 normal = normalize(vec3(h - hx, h - hy, e * 2.0));

                vec3 lightDir = normalize(vec3(-0.5, 0.5, 0.8));
                vec3 viewDir = vec3(0.0, 0.0, 1.0);
                vec3 halfDir = normalize(lightDir + viewDir);
                
                float specular = pow(max(dot(normal, halfDir), 0.0), ${glFloat(CONFIG.WATER.SPECULAR_POWER)}); 
                
                vec2 distortedUV = uv + normal.xy * ${glFloat(CONFIG.WATER.REFRACTION_STR)};
                float noiseVal = noise(distortedUV * 3.0 + u_time * 0.1);
                
                // Base Water Color
                vec3 finalColor = mix(${glVec3(CONFIG.WATER.COLOR_DEEP)}, ${glVec3(CONFIG.WATER.COLOR_SHALLOW)}, noiseVal + h * 2.0);
                
                float caustics = smoothstep(0.6, 1.0, noise(p*8.0 + u_time + normal.xy));
                finalColor += caustics * 0.08 * vec3(0.7, 0.9, 1.0);
                finalColor += vec3(1.0) * specular * ${glFloat(CONFIG.WATER.SPECULAR_INTENSITY)};

                // Snake Shadow
                vec2 shadowOffset = vec2(0.04, -0.04);
                float dSnakeShadow = 100.0;
                for (int i = 0; i < MAX_SNAKE; i++) {
                    if (i >= u_snakeLen - 1) break;
                    dSnakeShadow = min(dSnakeShadow, length(p - shadowOffset - u_snake[i])); 
                }
                if (dSnakeShadow < ${glFloat(CONFIG.SNAKE_VISUALS.RADIUS)}) finalColor *= 0.6;

                // --- SCENE LIGHTING FROM APPLE ---
                float dToApple = length(p - u_apple.xy);
                
                // Configurable Falloff
                float lightAtten = 1.0 / (1.0 + dToApple * dToApple * ${glFloat(CONFIG.LIGHTING.FALLOFF_STEEPNESS)});
                lightAtten *= 1.0 / (1.0 + u_apple.z * 5.0); // Dim when high up
                
                // Add reflection to water
                vec3 appleLightCol = ${glVec3(CONFIG.APPLE.COLOR)};
                
                // 1. Diffuse Glow on water surface
                finalColor += appleLightCol * lightAtten * 0.2;
                
                // 2. Specular Reflection (The bright spot on the waves)
                vec3 appleLightDir = normalize(vec3(u_apple.xy - p, 0.2)); 
                vec3 appleReflect = reflect(-appleLightDir, normal);
                float appleSpec = pow(max(dot(appleReflect, viewDir), 0.0), 10.0);
                
                finalColor += appleLightCol * appleSpec * lightAtten * ${glFloat(CONFIG.LIGHTING.WATER_REFLECTION_STR)};


                // --- RENDER OBJECTS ---
                vec3 objCol = vec3(0.0);
                float objHeight = 0.0;
                vec2 objP = p + normal.xy * 0.01; 
                if (u_apple.z > 0.01) objP = p; 

                getObjects(objP, uv, objCol, objHeight);

                if (length(objCol) > 0.0) {
                    finalColor = objCol; 
                }

                // Vignette
                float vig = 1.0 - length(uv - 0.5) * 0.5;
                finalColor *= vig;

                gl_FragColor = vec4(finalColor, 1.0);
            }
        `;

        // ==================================================================================
        //  ENGINE
        // ==================================================================================
        const canvas = document.getElementById('glcanvas');
        const gl = canvas.getContext('webgl', { alpha: false, depth: false });
        const uiScore = document.getElementById('score');

        function resize() {
            const dpr = Math.min(window.devicePixelRatio || 1, 1.5);
            canvas.width = window.innerWidth * dpr;
            canvas.height = window.innerHeight * dpr;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        window.addEventListener('resize', resize);
        resize();

        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(shader));
            }
            return shader;
        }

        const program = gl.createProgram();
        gl.attachShader(program, createShader(gl, gl.VERTEX_SHADER, VERTEX_SOURCE));
        gl.attachShader(program, createShader(gl, gl.FRAGMENT_SHADER, FRAGMENT_SOURCE));
        gl.linkProgram(program);
        gl.useProgram(program);

        gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1]), gl.STATIC_DRAW);
        gl.enableVertexAttribArray(gl.getAttribLocation(program, "position"));
        gl.vertexAttribPointer(gl.getAttribLocation(program, "position"), 2, gl.FLOAT, false, 0, 0);

        const locs = {
            res: gl.getUniformLocation(program, "u_resolution"),
            time: gl.getUniformLocation(program, "u_time"),
            snake: gl.getUniformLocation(program, "u_snake"),
            snakeLen: gl.getUniformLocation(program, "u_snakeLen"),
            apple: gl.getUniformLocation(program, "u_apple"),
            appleSplash: gl.getUniformLocation(program, "u_appleSplash"),
            ripples: gl.getUniformLocation(program, "u_ripples"),
            rippleCount: gl.getUniformLocation(program, "u_rippleCount")
        };

        let snake = [];
        for (let i = 0; i < CONFIG.GAME.START_LENGTH; i++) snake.push({ x: 0, y: -i * CONFIG.GAME.SEGMENT_DIST });
        let dir = { x: 0, y: 1 };
        let inputQ = [];
        let score = 0;
        let apple = { x: 0, y: 0.5, z: 2.0, falling: true };
        let splashTimer = 0.0;
        let ripples = [];
        let rippleDropTimer = 0;

        function spawnApple() {
            const aspect = canvas.width / canvas.height;
            apple.x = (Math.random() * 2 - 1) * aspect * 0.8;
            apple.y = (Math.random() * 2 - 1) * 0.8;
            apple.z = 2.0;
            apple.falling = true;
            splashTimer = 0.0;
        }
        spawnApple();

        function handleInput(newDir) {
            const last = inputQ.length > 0 ? inputQ[inputQ.length - 1] : dir;
            if (newDir.x !== 0 && last.x === 0) inputQ.push(newDir);
            if (newDir.y !== 0 && last.y === 0) inputQ.push(newDir);
        }

        window.addEventListener('keydown', e => {
            if (e.key === "ArrowUp") handleInput({ x: 0, y: 1 });
            if (e.key === "ArrowDown") handleInput({ x: 0, y: -1 });
            if (e.key === "ArrowLeft") handleInput({ x: -1, y: 0 });
            if (e.key === "ArrowRight") handleInput({ x: 1, y: 0 });
        });

        let tx = 0, ty = 0;
        canvas.addEventListener('touchstart', e => { tx = e.changedTouches[0].screenX; ty = e.changedTouches[0].screenY; }, { passive: false });
        canvas.addEventListener('touchend', e => {
            let dx = e.changedTouches[0].screenX - tx;
            let dy = e.changedTouches[0].screenY - ty;
            if (Math.max(Math.abs(dx), Math.abs(dy)) > CONFIG.GAME.TURN_SENSITIVITY) {
                if (Math.abs(dx) > Math.abs(dy)) handleInput(dx > 0 ? { x: 1, y: 0 } : { x: -1, y: 0 });
                else handleInput(dy > 0 ? { x: 0, y: -1 } : { x: 0, y: 1 });
            }
        }, { passive: false });

        function loop(now) {
            let totalTime = now * 0.001;

            if (inputQ.length) dir = inputQ.shift();

            // Move Head
            let head = { x: snake[0].x + dir.x * CONFIG.GAME.SPEED, y: snake[0].y + dir.y * CONFIG.GAME.SPEED };
            const aspect = canvas.width / canvas.height;

            if (head.x > aspect) { snake.forEach(s => s.x -= 2 * aspect); head.x -= 2 * aspect; }
            if (head.x < -aspect) { snake.forEach(s => s.x += 2 * aspect); head.x += 2 * aspect; }
            if (head.y > 1.0) { snake.forEach(s => s.y -= 2.0); head.y -= 2.0; }
            if (head.y < -1.0) { snake.forEach(s => s.y += 2.0); head.y += 2.0; }

            // Ripples
            rippleDropTimer++;
            if (rippleDropTimer > CONFIG.WAKE.TRAIL_DROP_INTERVAL) {
                ripples.push({ x: head.x, y: head.y, age: 0.0 });
                rippleDropTimer = 0;
            }
            for (let i = ripples.length - 1; i >= 0; i--) {
                ripples[i].age += 0.016;
                if (ripples[i].age > CONFIG.WAKE.TRAIL_LIFESPAN) ripples.splice(i, 1);
            }
            if (ripples.length > CONFIG.WAKE.TRAIL_MAX_COUNT) ripples.shift();

            // Update Body
            let nextSnake = [head];
            for (let i = 1; i < snake.length; i++) {
                let prev = nextSnake[i - 1];
                let curr = snake[i];
                let dx = curr.x - prev.x; let dy = curr.y - prev.y;
                let d = Math.sqrt(dx * dx + dy * dy);
                if (d > CONFIG.GAME.SEGMENT_DIST) {
                    let r = (d - CONFIG.GAME.SEGMENT_DIST) / d;
                    curr.x -= dx * r; curr.y -= dy * r;
                }
                nextSnake.push(curr);
            }
            snake = nextSnake;

            // Apple
            if (apple.falling) {
                apple.z -= 0.05;
                if (apple.z <= 0) { apple.z = 0; apple.falling = false; splashTimer = 0.001; }
            } else {
                let dx = head.x - apple.x; let dy = head.y - apple.y;
                if (Math.sqrt(dx * dx + dy * dy) < 0.1) {
                    score++; uiScore.innerText = "Score: " + score;
                    snake.push({ ...snake[snake.length - 1] }); spawnApple();
                }
            }
            if (splashTimer > 0) { splashTimer += 0.015; if (splashTimer > 2.0) splashTimer = 0; }

            // Collision
            for (let i = 10; i < snake.length; i++) {
                let dx = head.x - snake[i].x; let dy = head.y - snake[i].y;
                if (Math.sqrt(dx * dx + dy * dy) < CONFIG.GAME.SEGMENT_DIST * 0.5) {
                    score = 0; uiScore.innerText = "Score: 0";
                    snake = [];
                    for (let k = 0; k < CONFIG.GAME.START_LENGTH; k++) snake.push({ x: 0, y: -k * CONFIG.GAME.SEGMENT_DIST });
                }
            }

            // Render
            let flatSnake = [];
            snake.forEach(s => flatSnake.push(s.x, s.y));
            while (flatSnake.length < CONFIG.GAME.MAX_SNAKE_RENDER * 2) flatSnake.push(0, 0);

            let flatRipples = [];
            ripples.forEach(r => flatRipples.push(r.x, r.y, r.age));
            while (flatRipples.length < CONFIG.WAKE.TRAIL_MAX_COUNT * 3) flatRipples.push(0, 0, 100.0);

            gl.uniform2fv(locs.res, [canvas.width, canvas.height]);
            gl.uniform1f(locs.time, totalTime);
            gl.uniform2fv(locs.snake, new Float32Array(flatSnake));
            gl.uniform1i(locs.snakeLen, snake.length);
            gl.uniform3fv(locs.ripples, new Float32Array(flatRipples));
            gl.uniform1i(locs.rippleCount, ripples.length);
            gl.uniform3f(locs.apple, apple.x, apple.y, apple.z);
            gl.uniform1f(locs.appleSplash, splashTimer);

            gl.drawArrays(gl.TRIANGLES, 0, 6);
            requestAnimationFrame(loop);
        }
        requestAnimationFrame(loop);
    </script>
</body>

</html>