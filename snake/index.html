<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Hydro Snake - Configurable</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
        }

        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
            touch-action: none;
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.9);
            font-family: 'Segoe UI', sans-serif;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.8);
            pointer-events: none;
            user-select: none;
            z-index: 10;
        }

        h1 {
            margin: 0;
            font-size: 24px;
            letter-spacing: 1px;
        }

        p {
            margin: 5px 0 0 0;
            font-size: 14px;
            opacity: 0.7;
        }
    </style>
</head>

<body>
    <div id="ui">
        <h1 id="score">Score: 0</h1>
        <p>Edit the CONFIG object in the source code to tweak physics!</p>
    </div>
    <canvas id="glcanvas"></canvas>

    <script>
        // ==================================================================================
        //  ⚙️ CONFIGURATION - PLAY WITH THESE VALUES ⚙️
        // ==================================================================================
        const CONFIG = {
            GAME: {
                SPEED: 0.008,             // Movement speed of the snake
                START_LENGTH: 7,         // Number of segments at start
                SEGMENT_DIST: 0.05,       // Distance between snake segments
                TURN_SENSITIVITY: 30,     // Minimum swipe distance (pixels) to register a turn
                MAX_SNAKE_RENDER: 60,     // Hard limit on segments rendered (Shader optimization)
            },

            WATER: {
                COLOR_DEEP: [0.0, 0.05, 0.2],   // RGB (0.0 to 1.0) - The dark part of water
                COLOR_SHALLOW: [0.0, 0.4, 0.6],    // RGB (0.0 to 1.0) - The light part of water

                WAVE_SPEED: 1.5,          // How fast the background waves move
                WAVE_HEIGHT_1: 0.04,      // Height of the large background waves
                WAVE_HEIGHT_2: 0.015,     // Height of the small detail waves
                NOISE_SCALE: 3.0,         // Zoom level of the water texture

                SPECULAR_POWER: 80.0,     // Shininess of the water (Higher = smaller, sharper highlights)
                SPECULAR_INTENSITY: 0.8,  // Brightness of the sun reflection
                REFRACTION_STR: 0.03,     // How much objects distort underwater
            },

            SNAKE_VISUALS: {
                RADIUS: 0.025,            // Thickness of the snake
                COLOR_BODY_1: [0.3, 0.8, 0.1], // Dark Green skin tone
                COLOR_BODY_2: [0.3, 0.8, 0.1], // Light Green skin tone
                COLOR_EYES: [1.0, 1.0, 0.0], // Yellow eyes
                SKIN_PATTERN_FREQ: 50.0,  // Density of the skin texture
            },

            APPLE: {
                RADIUS: 0.035,            // Size of the apple
                COLOR: [0.9, 0.1, 0.1],   // Red apple
                FALL_SPEED: 0.05,         // How fast it drops from sky
                START_HEIGHT: 2.0,        // Height it drops from
            },

            // THE WAKE & RIPPLE PHYSICS
            WAKE: {
                // 1. Head "Bow Wave" (The continuous push in front of head)
                HEAD_PRESSURE_SIZE: 0.002,    // How wide the pressure wave is at the head
                HEAD_PRESSURE_HEIGHT: 0.005,  // How high the water rises at the head
                HEAD_WAVE_FREQ: 0.0,        // Frequency of the ripples at the nose

                // 2. Trail Ripples (The ones left behind)
                TRAIL_DROP_INTERVAL: 12,     // Drop a ripple every X frames (Lower = smoother trail, Higher = gap in trail)
                TRAIL_LIFESPAN: 1,         // How many seconds a ripple lasts before disappearing
                TRAIL_MAX_COUNT: 8,         // Max ripples allowed at once (Keep < 20 for mobile performance!)

                RIPPLE_SPEED: 50.0,          // How fast rings expand outward
                RIPPLE_HEIGHT: 0.012,         // How deep/high the ripples are
                RIPPLE_WIDTH: 0.015,          // Thickness of the ripple ring
            }
        };

        // ==================================================================================
        //  SHADER GENERATORS (Injects Config into GLSL)
        // ==================================================================================

        // Helper: Converts JS number to GLSL float string (e.g. 1 -> "1.0") to prevent crash
        const glFloat = (n) => Number.isInteger(n) ? n.toFixed(1) : n.toString();
        const glVec3 = (arr) => `vec3(${glFloat(arr[0])}, ${glFloat(arr[1])}, ${glFloat(arr[2])})`;

        const VERTEX_SOURCE = `
            attribute vec2 position;
            void main() { gl_Position = vec4(position, 0.0, 1.0); }
        `;

        const FRAGMENT_SOURCE = `
            precision mediump float;

            uniform vec2 u_resolution;
            uniform float u_time;
            
            // Snake Data
            #define MAX_SNAKE ${CONFIG.GAME.MAX_SNAKE_RENDER}
            uniform vec2 u_snake[MAX_SNAKE];
            uniform int u_snakeLen;
            
            // Apple Data
            uniform vec3 u_apple;
            uniform float u_appleSplash;

            // Ripple Trail Data
            #define MAX_RIPPLES ${CONFIG.WAKE.TRAIL_MAX_COUNT}
            uniform vec3 u_ripples[MAX_RIPPLES]; // x, y, time_alive
            uniform int u_rippleCount;

            // --- NOISE ---
            vec2 hash( vec2 p ) {
                p = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );
                return -1.0 + 2.0*fract(sin(p)*43758.5453123);
            }

            float noise( in vec2 p ) {
                const float K1 = 0.366025404; const float K2 = 0.211324865; 
                vec2 i = floor( p + (p.x+p.y)*K1 );
                vec2 a = p - i + (i.x+i.y)*K2;
                float m = step(a.y,a.x); vec2 o = vec2(m,1.0-m);
                vec2 b = a - o + K2; vec2 c = a - 1.0 + 2.0*K2;
                vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );
                vec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));
                return dot( n, vec3(70.0) );
            }

            float sdSegment( in vec2 p, in vec2 a, in vec2 b ) {
                vec2 pa = p-a, ba = b-a;
                float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );
                return length( pa - ba*h );
            }

            // --- DYNAMIC HEIGHT MAP ---
            float getHeight(vec2 p) {
                float height = 0.0;
                float t = u_time * ${glFloat(CONFIG.WATER.WAVE_SPEED)};

                // 1. Background Waves
                height += noise(p * ${glFloat(CONFIG.WATER.NOISE_SCALE)} + vec2(t*0.2, t*0.1)) * ${glFloat(CONFIG.WATER.WAVE_HEIGHT_1)};
                height += noise(p * ${glFloat(CONFIG.WATER.NOISE_SCALE * 2.0)} - vec2(t*0.1, 0.0)) * ${glFloat(CONFIG.WATER.WAVE_HEIGHT_2)};

                // 2. Head Bow Wave (Immediate displacement)
                float dHead = length(p - u_snake[0]);
                float headWake = smoothstep(${glFloat(CONFIG.WAKE.HEAD_PRESSURE_SIZE)}, 0.0, dHead);
                height += headWake * ${glFloat(CONFIG.WAKE.HEAD_PRESSURE_HEIGHT)} * sin(dHead * ${glFloat(CONFIG.WAKE.HEAD_WAVE_FREQ)} - u_time * 15.0);

                // 3. Trail Ripples
                for(int i=0; i<MAX_RIPPLES; i++){
                    if(i >= u_rippleCount) break;
                    vec3 r = u_ripples[i];
                    float d = length(p - r.xy);
                    
                    // Wave Physics
                    float wave = sin(d * ${glFloat(CONFIG.WAKE.RIPPLE_SPEED)} - r.z * ${glFloat(CONFIG.WAKE.RIPPLE_SPEED * 0.5)});
                    
                    // Expanding Ring Mask
                    float radius = r.z * 0.5 + 0.05; 
                    float mask = exp(-pow(d - radius, 2.0) / (${glFloat(CONFIG.WAKE.RIPPLE_WIDTH * 0.1)} + r.z*0.01));

                    // Fade out
                    float alpha = smoothstep(${glFloat(CONFIG.WAKE.TRAIL_LIFESPAN)}, 0.0, r.z);

                    height += wave * mask * ${glFloat(CONFIG.WAKE.RIPPLE_HEIGHT)} * alpha;
                }

                // 4. Apple Splash (Reuse ripple constants for consistency)
                if (u_appleSplash > 0.0) {
                    float dApple = length(p - u_apple.xy);
                    float wave = sin(dApple * ${glFloat(CONFIG.WAKE.RIPPLE_SPEED)} - u_appleSplash * 20.0);
                    float expandRadius = u_appleSplash * 1.0; 
                    float mask = exp(-pow(dApple - expandRadius, 2.0) / 0.02);
                    float dampen = smoothstep(2.0, 0.0, u_appleSplash);
                    height += wave * mask * 0.15 * dampen;
                }

                return height;
            }

            void main() {
                vec2 uv = gl_FragCoord.xy / u_resolution.xy;
                vec2 p = (2.0*gl_FragCoord.xy - u_resolution.xy) / u_resolution.y;

                // Normals
                float e = 0.005;
                float h = getHeight(p);
                float hx = getHeight(p + vec2(e, 0.0));
                float hy = getHeight(p + vec2(0.0, e));
                vec3 normal = normalize(vec3(h - hx, h - hy, e * 2.0));

                // Lighting
                vec3 lightDir = normalize(vec3(-0.5, 0.5, 0.8));
                vec3 viewDir = vec3(0.0, 0.0, 1.0);
                vec3 halfDir = normalize(lightDir + viewDir);
                float specular = pow(max(dot(normal, halfDir), 0.0), ${glFloat(CONFIG.WATER.SPECULAR_POWER)}); 
                
                // Color & Refraction
                vec2 distortedUV = uv + normal.xy * ${glFloat(CONFIG.WATER.REFRACTION_STR)};
                float noiseVal = noise(distortedUV * 3.0 + u_time * 0.1);
                
                vec3 waterCol = mix(${glVec3(CONFIG.WATER.COLOR_DEEP)}, ${glVec3(CONFIG.WATER.COLOR_SHALLOW)}, noiseVal + h * 1.5);

                // Draw Objects
                vec2 pDis = p + normal.xy * 0.02; 
                vec3 objectCol = vec3(0.0);
                float objectMask = 0.0;

                // Apple
                vec2 applePos = u_apple.xy;
                float scale = 1.0 + u_apple.z * 0.5;
                vec2 checkPos = (u_apple.z > 0.01) ? p : pDis;
                float rad = (u_apple.z > 0.01) ? ${glFloat(CONFIG.APPLE.RADIUS)} * scale : ${glFloat(CONFIG.APPLE.RADIUS)};
                
                float dApple = length(checkPos - applePos) - rad;
                if (dApple < 0.0) {
                    float appleLight = dot(normalize(vec3(checkPos-applePos, 0.5)), lightDir);
                    objectCol = ${glVec3(CONFIG.APPLE.COLOR)} * (0.6 + 0.4*appleLight);
                    objectMask = 1.0;
                }

                // Snake
                float dSnake = 100.0;
                for (int i = 0; i < MAX_SNAKE; i++) {
                    if (i >= u_snakeLen - 1) break;
                    float seg = sdSegment(pDis, u_snake[i], u_snake[i+1]);
                    dSnake = min(dSnake, seg);
                }
                
                if (dSnake < ${glFloat(CONFIG.SNAKE_VISUALS.RADIUS)}) {
                    float pat = 0.5 + 0.5 * sin(pDis.x * ${glFloat(CONFIG.SNAKE_VISUALS.SKIN_PATTERN_FREQ)} + pDis.y * ${glFloat(CONFIG.SNAKE_VISUALS.SKIN_PATTERN_FREQ)});
                    vec3 skinCol = mix(${glVec3(CONFIG.SNAKE_VISUALS.COLOR_BODY_1)}, ${glVec3(CONFIG.SNAKE_VISUALS.COLOR_BODY_2)}, pat);
                    
                    // Eyes
                    if (length(pDis - u_snake[0]) < ${glFloat(CONFIG.SNAKE_VISUALS.RADIUS)}) {
                        vec2 dir = normalize(u_snake[0] - u_snake[1]);
                        vec2 side = vec2(-dir.y, dir.x);
                        float eyeOffset = ${glFloat(CONFIG.SNAKE_VISUALS.RADIUS * 0.4)};
                        if (length(pDis - (u_snake[0] + side * eyeOffset - dir * 0.01)) < 0.008 || 
                            length(pDis - (u_snake[0] - side * eyeOffset - dir * 0.01)) < 0.008) {
                            skinCol = ${glVec3(CONFIG.SNAKE_VISUALS.COLOR_EYES)};
                        }
                    }
                    objectCol = skinCol;
                    objectMask = 1.0;
                }
                
                // Composite
                vec3 finalColor = waterCol;
                if (objectMask > 0.0) {
                    float fog = (u_apple.z > 0.0 && dApple < 0.0) ? 0.0 : 0.2;
                    finalColor = mix(objectCol, waterCol, fog);
                }

                finalColor += vec3(1.0) * specular * ${glFloat(CONFIG.WATER.SPECULAR_INTENSITY)};
                float caustics = smoothstep(0.7, 1.0, noise(p*8.0 + u_time + normal.xy));
                finalColor += caustics * 0.05 * vec3(0.8, 0.9, 1.0);

                // Shadow
                if (u_apple.z > 0.1) {
                    if (length(pDis - (u_apple.xy + vec2(0.05, -0.05))) - ${glFloat(CONFIG.APPLE.RADIUS * 0.6)} < 0.0) finalColor *= 0.6;
                }

                gl_FragColor = vec4(finalColor, 1.0);
            }
        `;

        // ==================================================================================
        //  ENGINE
        // ==================================================================================
        const canvas = document.getElementById('glcanvas');
        const gl = canvas.getContext('webgl', { alpha: false, depth: false });
        const uiScore = document.getElementById('score');

        function resize() {
            const dpr = Math.min(window.devicePixelRatio || 1, 1.5);
            const w = Math.floor(window.innerWidth * dpr);
            const h = Math.floor(window.innerHeight * dpr);
            if (canvas.width !== w || canvas.height !== h) {
                canvas.width = w; canvas.height = h;
            }
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        window.addEventListener('resize', resize);
        resize();

        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error("Shader Compile Error:", gl.getShaderInfoLog(shader));
            }
            return shader;
        }

        const program = gl.createProgram();
        gl.attachShader(program, createShader(gl, gl.VERTEX_SHADER, VERTEX_SOURCE));
        gl.attachShader(program, createShader(gl, gl.FRAGMENT_SHADER, FRAGMENT_SOURCE));
        gl.linkProgram(program);
        gl.useProgram(program);

        gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1]), gl.STATIC_DRAW);
        const posLoc = gl.getAttribLocation(program, "position");
        gl.enableVertexAttribArray(posLoc);
        gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

        const locs = {
            res: gl.getUniformLocation(program, "u_resolution"),
            time: gl.getUniformLocation(program, "u_time"),
            snake: gl.getUniformLocation(program, "u_snake"),
            snakeLen: gl.getUniformLocation(program, "u_snakeLen"),
            apple: gl.getUniformLocation(program, "u_apple"),
            appleSplash: gl.getUniformLocation(program, "u_appleSplash"),
            ripples: gl.getUniformLocation(program, "u_ripples"),
            rippleCount: gl.getUniformLocation(program, "u_rippleCount")
        };

        // --- GAME VARIABLES ---
        let snake = [];
        for (let i = 0; i < CONFIG.GAME.START_LENGTH; i++) snake.push({ x: 0, y: -i * CONFIG.GAME.SEGMENT_DIST });
        let dir = { x: 0, y: 1 };
        let inputQ = [];
        let score = 0;

        let apple = { x: 0, y: 0.5, z: CONFIG.APPLE.START_HEIGHT, falling: true };
        let splashTimer = 0.0;

        let ripples = [];
        let rippleDropTimer = 0;

        function spawnApple() {
            const aspect = canvas.width / canvas.height;
            apple.x = (Math.random() * 2 - 1) * aspect * 0.8;
            apple.y = (Math.random() * 2 - 1) * 0.8;
            apple.z = CONFIG.APPLE.START_HEIGHT;
            apple.falling = true;
            splashTimer = 0.0;
        }
        spawnApple();

        function handleInput(newDir) {
            const last = inputQ.length > 0 ? inputQ[inputQ.length - 1] : dir;
            if (newDir.x !== 0 && last.x === 0) inputQ.push(newDir);
            if (newDir.y !== 0 && last.y === 0) inputQ.push(newDir);
        }

        window.addEventListener('keydown', e => {
            if (e.key === "ArrowUp") handleInput({ x: 0, y: 1 });
            if (e.key === "ArrowDown") handleInput({ x: 0, y: -1 });
            if (e.key === "ArrowLeft") handleInput({ x: -1, y: 0 });
            if (e.key === "ArrowRight") handleInput({ x: 1, y: 0 });
        });

        // Touch
        let tx = 0, ty = 0;
        canvas.addEventListener('touchstart', e => { tx = e.changedTouches[0].screenX; ty = e.changedTouches[0].screenY; }, { passive: false });
        canvas.addEventListener('touchend', e => {
            let dx = e.changedTouches[0].screenX - tx;
            let dy = e.changedTouches[0].screenY - ty;
            if (Math.max(Math.abs(dx), Math.abs(dy)) > CONFIG.GAME.TURN_SENSITIVITY) {
                if (Math.abs(dx) > Math.abs(dy)) handleInput(dx > 0 ? { x: 1, y: 0 } : { x: -1, y: 0 });
                else handleInput(dy > 0 ? { x: 0, y: -1 } : { x: 0, y: 1 });
            }
        }, { passive: false });

        function loop(now) {
            let totalTime = now * 0.001;
            let shaderTime = totalTime % 10000.0;

            if (inputQ.length) dir = inputQ.shift();

            // Move Head
            let head = { x: snake[0].x + dir.x * CONFIG.GAME.SPEED, y: snake[0].y + dir.y * CONFIG.GAME.SPEED };
            const aspect = canvas.width / canvas.height;

            // Wall Wrap
            if (head.x > aspect) { snake.forEach(s => s.x -= 2 * aspect); head.x -= 2 * aspect; }
            if (head.x < -aspect) { snake.forEach(s => s.x += 2 * aspect); head.x += 2 * aspect; }
            if (head.y > 1.0) { snake.forEach(s => s.y -= 2.0); head.y -= 2.0; }
            if (head.y < -1.0) { snake.forEach(s => s.y += 2.0); head.y += 2.0; }

            // RIPPLE SPAWNING
            rippleDropTimer++;
            if (rippleDropTimer > CONFIG.WAKE.TRAIL_DROP_INTERVAL) {
                ripples.push({ x: head.x, y: head.y, age: 0.0 });
                rippleDropTimer = 0;
            }

            // UPDATE RIPPLES
            for (let i = ripples.length - 1; i >= 0; i--) {
                ripples[i].age += 0.016;
                if (ripples[i].age > CONFIG.WAKE.TRAIL_LIFESPAN) ripples.splice(i, 1);
            }
            if (ripples.length > CONFIG.WAKE.TRAIL_MAX_COUNT) ripples.shift();

            // UPDATE BODY
            let nextSnake = [head];
            for (let i = 1; i < snake.length; i++) {
                let prev = nextSnake[i - 1];
                let curr = snake[i];
                let dx = curr.x - prev.x; let dy = curr.y - prev.y;
                let d = Math.sqrt(dx * dx + dy * dy);
                if (d > CONFIG.GAME.SEGMENT_DIST) {
                    let r = (d - CONFIG.GAME.SEGMENT_DIST) / d;
                    curr.x -= dx * r; curr.y -= dy * r;
                }
                nextSnake.push(curr);
            }
            snake = nextSnake;

            // APPLE PHYSICS
            if (apple.falling) {
                apple.z -= CONFIG.APPLE.FALL_SPEED;
                if (apple.z <= 0) { apple.z = 0; apple.falling = false; splashTimer = 0.001; }
            } else {
                // Collision
                let dx = head.x - apple.x; let dy = head.y - apple.y;
                if (Math.sqrt(dx * dx + dy * dy) < 0.1) {
                    score++; uiScore.innerText = "Score: " + score;
                    snake.push({ ...snake[snake.length - 1] }); spawnApple();
                }
            }
            if (splashTimer > 0) { splashTimer += 0.015; if (splashTimer > 2.0) splashTimer = 0; }

            // SELF COLLISION
            for (let i = 10; i < snake.length; i++) {
                let dx = head.x - snake[i].x; let dy = head.y - snake[i].y;
                if (Math.sqrt(dx * dx + dy * dy) < CONFIG.GAME.SEGMENT_DIST * 0.5) {
                    score = 0; uiScore.innerText = "Score: 0";
                    snake = [];
                    for (let k = 0; k < CONFIG.GAME.START_LENGTH; k++) snake.push({ x: 0, y: -k * CONFIG.GAME.SEGMENT_DIST });
                }
            }

            // RENDER PREP
            let flatSnake = [];
            snake.forEach(s => flatSnake.push(s.x, s.y));
            // Fill Buffer to prevent GL errors
            while (flatSnake.length < CONFIG.GAME.MAX_SNAKE_RENDER * 2) flatSnake.push(0, 0);

            let flatRipples = [];
            for (let i = 0; i < ripples.length; i++) {
                flatRipples.push(ripples[i].x, ripples[i].y, ripples[i].age);
            }
            while (flatRipples.length < CONFIG.WAKE.TRAIL_MAX_COUNT * 3) flatRipples.push(0, 0, 100.0);

            gl.uniform2fv(locs.res, [canvas.width, canvas.height]);
            gl.uniform1f(locs.time, shaderTime);
            gl.uniform2fv(locs.snake, new Float32Array(flatSnake));
            gl.uniform1i(locs.snakeLen, snake.length);
            gl.uniform3fv(locs.ripples, new Float32Array(flatRipples));
            gl.uniform1i(locs.rippleCount, ripples.length);
            gl.uniform3f(locs.apple, apple.x, apple.y, apple.z);
            gl.uniform1f(locs.appleSplash, splashTimer);

            gl.drawArrays(gl.TRIANGLES, 0, 6);
            requestAnimationFrame(loop);
        }
        requestAnimationFrame(loop);
    </script>
</body>

</html>